uses data.String
uses data.StringUtil
uses reflect.Type
uses data.adt.Stack
uses FunctionData
uses Generator

const int PRINT_FREQ = 500

component provides FeatureBuilder requires data.adt.Stack, data.StringUtil su, io.Output output, data.IntUtil iu {

  /* FeatureBuilder:FeatureBuilder()
    {
    } */

  // The maximum ammount features vectors can differ and still be considered similar.
  int maxDeviation

  char inputVarType[]

  FunctionData functionData

  PIFixed providedFeatures

  int acceptedPrograms
  int rejectedPrograms
  int acceptedBranches
  int rejectedBranches

  int printCount

  String parameterTypes[]

  PIFixed FeatureBuilder:getNewFeatureVector() {
    PIFixed features = new PIFixed()
    features.varTypes = new VariableTypes()
    features.asmtTypes = new AssignmentTypes()
    features.remainingLinesInBlock = new Stack()
    return features
  }

  void FeatureBuilder:setMaxDeviation(int _maxDeviation) {
    maxDeviation = _maxDeviation
  }

  void FeatureBuilder:setProvidedFeatures(PIFixed _providedFeatures) {
    providedFeatures = _providedFeatures
  }

  void FeatureBuilder:setFunctionData(FunctionData _functionData) {
    functionData = _functionData
  }

  void FeatureBuilder:setParameterTypes(String _paramTypes[]) {
    parameterTypes = _paramTypes
  }

  String[] FeatureBuilder:getParameterTypes() {
    return parameterTypes
  }

  bool FeatureBuilder:areDeclarationsComplete(int totalVars) {
    return totalVars == providedFeatures.totalVars
  }

  int FeatureBuilder:totalVarsRequired() {
    return providedFeatures.totalVars
  }

  int FeatureBuilder:acceptedBranches() {
    return acceptedBranches
  }

  void FeatureBuilder:resetAcceptedRejectedBranches() {
    acceptedBranches = 0
    rejectedBranches = 0
    acceptedPrograms = 0
    rejectedPrograms = 0
  }

  /* update the assignment type counts */
  AssignmentTypes updateAssignmentTypes(AssignmentTypes asmtTypes, int asmtType, char rhsAssign[], char rhsOpType[]) {
    AssignmentTypes ats = clone asmtTypes
    ats.literalValue = null
    ats.opType = null
    if (asmtType == 1)
    {
      ats.totalVarToLit += 1
      ats.literalValue = rhsAssign
      ats.litValues = new String[](ats.litValues, new String(rhsAssign))
    }
    else if (asmtType == 2) ats.totalVarToVar += 1
    else if (asmtType == 3) ats.totalVarToInd += 1
    else if (asmtType == 4) ats.totalVarToField += 1
    else if (asmtType == 5) ats.totalVarToData += 1
    else if (asmtType == 6) ats.totalVarToObj += 1
    else if (asmtType == 7) ats.totalVarToArrConcat += 1
    else if (asmtType == 8) {
      ats.totalVarToArrClone += 1
      /* output.println("ArrClone") */
    }
    else if (asmtType == 9) ats.totalVarToDataClone += 1
    else if (asmtType == 10) {
      ats.totalVarToFunc += 1
      ats.opType = rhsOpType
      ats.opTypes = new String[](ats.opTypes, new String(rhsOpType))
    }
    else if (asmtType == 11) ats.totalVarToGOFunc += 1
    else if (asmtType == 12) ats.totalVarToLOFunc += 1
    // LHS = variable indices
    else if (asmtType == 13)
    {
      ats.totalIndToLit += 1
      ats.literalValue = rhsAssign
      ats.litValues = new String[](ats.litValues, new String(rhsAssign))
    }
    else if (asmtType == 14) ats.totalIndToVar += 1
    else if (asmtType == 15) ats.totalIndToInd += 1
    else if (asmtType == 16) ats.totalIndToField += 1
    else if (asmtType == 17) ats.totalIndToData += 1
    else if (asmtType == 18) ats.totalIndToObj += 1
    else if (asmtType == 19) ats.totalIndToArrConcat += 1
    else if (asmtType == 20) ats.totalIndToArrClone += 1
    else if (asmtType == 21) ats.totalIndToDataClone += 1
    else if (asmtType == 22) {
      ats.totalIndToFunc += 1
      ats.opType = rhsOpType
      ats.opTypes = new String[](ats.opTypes, new String(rhsOpType))
    }
    else if (asmtType == 23) ats.totalIndToGOFunc += 1
    else if (asmtType == 24) ats.totalIndToLOFunc += 1
    // LHS = data
    else if (asmtType == 25)
    {
      ats.totalDataToLit += 1
      ats.literalValue = rhsAssign
      ats.litValues = new String[](ats.litValues, new String(rhsAssign))
    }
    else if (asmtType == 26) ats.totalDataToVar += 1
    else if (asmtType == 27) ats.totalDataToInd += 1
    else if (asmtType == 28) ats.totalDataToField += 1
    else if (asmtType == 29) ats.totalDataToData += 1
    else if (asmtType == 30) ats.totalDataToObj += 1
    else if (asmtType == 31) ats.totalDataToArrConcat += 1
    else if (asmtType == 32) ats.totalDataToArrClone += 1
    else if (asmtType == 33) ats.totalDataToDataClone += 1
    else if (asmtType == 34) {
      ats.totalDataToFunc += 1
      ats.opType = rhsOpType
      ats.opTypes = new String[](ats.opTypes, new String(rhsOpType))
    }
    else if (asmtType == 35) ats.totalDataToGOFunc += 1
    else if (asmtType == 36) ats.totalDataToLOFunc += 1
    /* else ats.literalValue = "" */
    return ats
  }

  // NOTE: If function overloading is possible, have separate functions for each type of FeatureVector (when more than PIFixed is available!)
  /* FeatureVector doUpdate(Node currentNode) { */
  PIFixed doUpdate(PIFixed existingFV, int lineType, char newLine[], int subLinesCount, int decType, int asmtType, char rhsAssign[], char rhsOpType[]) {
    //Node node = clone currentNode
    PIFixed update = clone existingFV //node.features
    /* update.nonBlankLines += 1 */
    //Operation lineInfo = node.lineInfo
    String tokens[] = getLineComponents(newLine)
    // Check if we are currently within a subscope:
    if (update.remainingLinesInBlock.getLength() != 0) {
      LineInfo lineInfo = update.remainingLinesInBlock.peek()
      if (lineInfo.linesRemaining == 0) {
        update.remainingLinesInBlock.remove(update.remainingLinesInBlock.peek())
      }
      if (update.remainingLinesInBlock.getLength() != 0) {
        lineInfo = update.remainingLinesInBlock.peek()
        lineInfo.linesRemaining -= 1
        update.remainingLinesInBlock.update(update.remainingLinesInBlock.peek(), lineInfo)
      }
    }
    if (lineType == 0) {
      // 0 = local variable call
      update.totalFunctionCalls += 1
      if (providedFeatures.totalFunctionCalls < update.totalFunctionCalls) update.isValid = false
    }
    else if (lineType == 1) {
      // 1 = declaration
      update.totalVars += 1
      if (providedFeatures.totalVars < update.totalVars) {
        update.isValid = false
        /* return null */
      }
      if (providedFeatures.totalVars >= update.totalLines) {
        // should not do any further declarations. Set declarations complete to TRUE.
        // can check here if we have enough declarations.

      }
      // OR if declarations complete, are provided total vars != current total vars, is valid = false
      // NOTE: declatations complete check must be done elsewhere, preferably on the first line after the last declaration only.
      /* if (tokens[0] == inputVarType) {
        update.nonInputVars += 1
      } */
      VariableTypes vts = update.varTypes
      if (decType == 1) {
        vts.totalInts += 1
        if (providedFeatures.varTypes.totalInts < vts.totalInts) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 2) {
        vts.totalDecs += 1
        if (providedFeatures.varTypes.totalDecs < vts.totalDecs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 3) {
        vts.totalChars += 1
        if (providedFeatures.varTypes.totalChars < vts.totalChars) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 4) {
        vts.totalBools += 1
        if (providedFeatures.varTypes.totalBools < vts.totalBools) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 5) {
        vts.totalDatas += 1
        if (providedFeatures.varTypes.totalDatas < vts.totalDatas) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 6) {
        vts.totalIntArrs += 1
        if (providedFeatures.varTypes.totalIntArrs < vts.totalIntArrs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 7) {
        vts.totalDecArrs += 1
        if (providedFeatures.varTypes.totalDecArrs < vts.totalDecArrs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 8) {
        vts.totalCharArrs += 1
        if (providedFeatures.varTypes.totalCharArrs < vts.totalCharArrs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 9) {
        vts.totalBoolArrs += 1
        if (providedFeatures.varTypes.totalBoolArrs < vts.totalBoolArrs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 10) {
        vts.totalDataArrs += 1
        if (providedFeatures.varTypes.totalDataArrs < vts.totalDataArrs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 11) {
        vts.totalObjs += 1
        if (providedFeatures.varTypes.totalObjs < vts.totalObjs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 12) {
        vts.totalObjArrs += 1
        if (providedFeatures.varTypes.totalObjArrs < vts.totalObjArrs) {
          update.isValid = false
          /* return null */
        }
      }
      else if (decType == 13) {
        vts.totalFuncArrs += 1
        if (providedFeatures.varTypes.totalFuncArrs < vts.totalFuncArrs) {
          update.isValid = false
          /* return null */
        }
      }
      update.varTypes = vts
    }
    else if (lineType == 2) {
      // 2 = assignment - we could increase the number of assignment types
      update.totalAssignments += 1
      update.asmtTypes = updateAssignmentTypes(update.asmtTypes, asmtType, rhsAssign, rhsOpType)
    }
    else if (lineType == 3) {
      // 3 = if statement
      update.totalIfs += 1
      // update average if statement length
      update.totalLoopLength += subLinesCount
      update.aveLoopLength = update.totalLoopLength / update.totalIfs
      // Update control block nesting info
      LineInfo nextCount = new LineInfo(subLinesCount)
      update.remainingLinesInBlock.add(nextCount)
      // Check if current nesting level is greater than previous maximum, if so, update maximum
      if (update.remainingLinesInBlock.getLength() > update.highestNestingLevel) {
        update.highestNestingLevel = update.remainingLinesInBlock.getLength()
      }
    }
    else if (lineType == 4) {
      // 4 = while loop
      update.totalWhiles += 1
      // Update average while loop length
      /* update.totalWhileLength += subLinesCount
      update.aveWhileLength = update.totalWhileLength / update.totalWhiles
      // Update control block nesting info
      LineInfo nextCount = new LineInfo(subLinesCount)
      update.remainingLinesInBlock.add(nextCount)
      // Check if current nesting level is greater than previous maximum, if so, update maximum
      if (update.remainingLinesInBlock.getLength() > update.highestNestingLevel) {
        update.highestNestingLevel = update.remainingLinesInBlock.getLength()
      } */
    }
    else if (lineType == 5) {
      // 5 = return
      update.totalReturns += 1
    }
    return update
  }

  // get a new PIFixed feature vector for the current feature vector (of a node) plus the new line.
  // May be easier/make more sense to just pass a Node and get the feature vector from there.
  /* PIFixed FeatureBuilder:updateFeatureVector(PIFixed current, String newLine, String inputVarType) { */
  PIFixed FeatureBuilder:updateFeatureVector(PIFixed existingFV, int lineType, char newLine[], int subLinesCount, int decType, int asmtType, char rhsAssign[], char rhsOpType[]) { //}, String inputVarType) {
    // Node node = clone newNode
    //FeatureVector current = node.features
    /* output.println("line: $(newLine), lineType: $(iu.intToString(lineType)), asmtType: $(iu.intToString(asmtType)), rhsAssign: $(rhsAssign), provided: $(providedFeatures.asmtTypes.literalValue)") */

    PIFixed features = getNewFeatureVector()
    if (existingFV != null) features = copyFeatures(existingFV)
    /* printFeatures(features) */

    features.totalLines += 1

    // blank line:
    if (newLine == null) {
      features.blankLines += 1
      // Or return 0 or -1? Or throw exception?
      /* return null */
    }
    else { //(features.totalLines > 0) {
      // Non blank line
      features = doUpdate(features, lineType, newLine, subLinesCount, decType, asmtType, rhsAssign, rhsOpType)
    }
    /* printFeatures(features) */

    return features
  }

  bool FeatureBuilder:hasMinLinesToCompleteFeatures(PIFixed current, int linesRemaining) { //}, int programLength) {
    //int currentLinesUsed = current.totalLines
    //int linesRemaining = programLength - currentLinesUsed
    //if (linesRemaining < 1) return false
    int minRequired = 0
    if (current.totalVars < providedFeatures.totalVars) {
      minRequired += (providedFeatures.totalVars - current.totalVars)
    }
    if (current.totalAssignments < providedFeatures.totalAssignments) {
      minRequired += (providedFeatures.totalAssignments - current.totalAssignments)
      // Check each asmtType now:
    }
    if (current.totalWhiles < providedFeatures.totalWhiles) {
      minRequired += (providedFeatures.totalWhiles - current.totalWhiles) * 2 // Minimum lines to make a control block is 3 lines? or 4? 1) while statement, 2) opening brace, 3) line, 4) closing brace
    }
    if (current.totalIfs < providedFeatures.totalIfs) {
      minRequired += (providedFeatures.totalIfs - current.totalIfs) * 2 // Minimum lines to make a control block is 3 lines? or 4? 1) while statement, 2) opening brace, 3) line, 4) closing brace
    }
    return minRequired <= linesRemaining
  }

  bool rejectAssignments(AssignmentTypes currentAsmtTypes, AssignmentTypes provAsmtTypes) {
    bool rejectAsmts = false
    // LHS =
    //while (rejectAsmts != true) {
      /* rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToLit > provAsmtTypes.totalVarToLit) || (currentAsmtTypes.totalIndToLit > provAsmtTypes.totalIndToLit) || (currentAsmtTypes.totalDataToLit > provAsmtTypes.totalDataToLit)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToVar > provAsmtTypes.totalVarToVar) || (currentAsmtTypes.totalIndToVar > provAsmtTypes.totalIndToVar) || (currentAsmtTypes.totalDataToVar > provAsmtTypes.totalDataToVar)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToInd > provAsmtTypes.totalVarToInd) || (currentAsmtTypes.totalIndToInd > provAsmtTypes.totalIndToInd) || (currentAsmtTypes.totalDataToInd > provAsmtTypes.totalDataToInd)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToField > provAsmtTypes.totalVarToField) || (currentAsmtTypes.totalIndToField > provAsmtTypes.totalIndToField) || (currentAsmtTypes.totalDataToField > provAsmtTypes.totalDataToField)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToData > provAsmtTypes.totalVarToData) || (currentAsmtTypes.totalIndToData > provAsmtTypes.totalIndToData) || (currentAsmtTypes.totalDataToData > provAsmtTypes.totalDataToData)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToObj > provAsmtTypes.totalVarToObj) || (currentAsmtTypes.totalIndToObj > provAsmtTypes.totalIndToObj) || (currentAsmtTypes.totalDataToObj > provAsmtTypes.totalDataToObj)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToArrConcat > provAsmtTypes.totalVarToArrConcat) || (currentAsmtTypes.totalIndToArrConcat > provAsmtTypes.totalIndToArrConcat) || (currentAsmtTypes.totalDataToArrConcat > provAsmtTypes.totalDataToArrConcat)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToArrClone > provAsmtTypes.totalVarToArrClone) || (currentAsmtTypes.totalIndToArrClone > provAsmtTypes.totalIndToArrClone) || (currentAsmtTypes.totalDataToArrClone > provAsmtTypes.totalDataToArrClone)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToDataClone > provAsmtTypes.totalVarToDataClone) || (currentAsmtTypes.totalIndToDataClone > provAsmtTypes.totalIndToDataClone) || (currentAsmtTypes.totalDataToDataClone > provAsmtTypes.totalDataToDataClone)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToFunc > provAsmtTypes.totalVarToFunc) || (currentAsmtTypes.totalIndToFunc > provAsmtTypes.totalIndToFunc) || (currentAsmtTypes.totalDataToFunc > provAsmtTypes.totalDataToFunc)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToGOFunc > provAsmtTypes.totalVarToGOFunc) || (currentAsmtTypes.totalIndToGOFunc > provAsmtTypes.totalIndToGOFunc) || (currentAsmtTypes.totalDataToGOFunc > provAsmtTypes.totalDataToGOFunc)
      rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToLOFunc > provAsmtTypes.totalVarToLOFunc) || (currentAsmtTypes.totalIndToLOFunc > provAsmtTypes.totalIndToLOFunc) || (currentAsmtTypes.totalDataToLOFunc > provAsmtTypes.totalDataToLOFunc) */
    //  return rejectAsmts
    //}

    if ((currentAsmtTypes.totalVarToLit > provAsmtTypes.totalVarToLit) || (currentAsmtTypes.totalIndToLit > provAsmtTypes.totalIndToLit) || (currentAsmtTypes.totalDataToLit > provAsmtTypes.totalDataToLit)) return true
    if ((currentAsmtTypes.totalVarToVar > provAsmtTypes.totalVarToVar) || (currentAsmtTypes.totalIndToVar > provAsmtTypes.totalIndToVar) || (currentAsmtTypes.totalDataToVar > provAsmtTypes.totalDataToVar)) return true
    if ((currentAsmtTypes.totalVarToInd > provAsmtTypes.totalVarToInd) || (currentAsmtTypes.totalIndToInd > provAsmtTypes.totalIndToInd) || (currentAsmtTypes.totalDataToInd > provAsmtTypes.totalDataToInd)) return true
    if ((currentAsmtTypes.totalVarToField > provAsmtTypes.totalVarToField) || (currentAsmtTypes.totalIndToField > provAsmtTypes.totalIndToField) || (currentAsmtTypes.totalDataToField > provAsmtTypes.totalDataToField)) return true
    if ((currentAsmtTypes.totalVarToData > provAsmtTypes.totalVarToData) || (currentAsmtTypes.totalIndToData > provAsmtTypes.totalIndToData) || (currentAsmtTypes.totalDataToData > provAsmtTypes.totalDataToData)) return true
    if ((currentAsmtTypes.totalVarToObj > provAsmtTypes.totalVarToObj) || (currentAsmtTypes.totalIndToObj > provAsmtTypes.totalIndToObj) || (currentAsmtTypes.totalDataToObj > provAsmtTypes.totalDataToObj)) return true
    if ((currentAsmtTypes.totalVarToArrConcat > provAsmtTypes.totalVarToArrConcat) || (currentAsmtTypes.totalIndToArrConcat > provAsmtTypes.totalIndToArrConcat) || (currentAsmtTypes.totalDataToArrConcat > provAsmtTypes.totalDataToArrConcat)) return true
    if ((currentAsmtTypes.totalVarToArrClone > provAsmtTypes.totalVarToArrClone) || (currentAsmtTypes.totalIndToArrClone > provAsmtTypes.totalIndToArrClone) || (currentAsmtTypes.totalDataToArrClone > provAsmtTypes.totalDataToArrClone)) return true
    if ((currentAsmtTypes.totalVarToDataClone > provAsmtTypes.totalVarToDataClone) || (currentAsmtTypes.totalIndToDataClone > provAsmtTypes.totalIndToDataClone) || (currentAsmtTypes.totalDataToDataClone > provAsmtTypes.totalDataToDataClone)) return true
    if ((currentAsmtTypes.totalVarToFunc > provAsmtTypes.totalVarToFunc) || (currentAsmtTypes.totalIndToFunc > provAsmtTypes.totalIndToFunc) || (currentAsmtTypes.totalDataToFunc > provAsmtTypes.totalDataToFunc)) return true
    if ((currentAsmtTypes.totalVarToGOFunc > provAsmtTypes.totalVarToGOFunc) || (currentAsmtTypes.totalIndToGOFunc > provAsmtTypes.totalIndToGOFunc) || (currentAsmtTypes.totalDataToGOFunc > provAsmtTypes.totalDataToGOFunc)) return true
    if ((currentAsmtTypes.totalVarToLOFunc > provAsmtTypes.totalVarToLOFunc) || (currentAsmtTypes.totalIndToLOFunc > provAsmtTypes.totalIndToLOFunc) || (currentAsmtTypes.totalDataToLOFunc > provAsmtTypes.totalDataToLOFunc)) return true

    return false
  }

  bool FeatureBuilder:rejectEarly(PIFixed currentFeatures, int linesRemaining) {
    // NOTE: complete!
    /* printFeatures(currentFeatures) */
    // Check if too many variables have been declared
    if (currentFeatures.totalVars > providedFeatures.totalVars) {
      return true
    }
    if (currentFeatures.varTypes.totalInts > providedFeatures.varTypes.totalInts) {
      return true
    }
    if (currentFeatures.varTypes.totalDecs > providedFeatures.varTypes.totalDecs) {
      return true
    }
    if (currentFeatures.varTypes.totalBools > providedFeatures.varTypes.totalBools) {
      return true
    }
    if (currentFeatures.varTypes.totalChars > providedFeatures.varTypes.totalChars) {
      return true
    }
    if (currentFeatures.varTypes.totalDatas > providedFeatures.varTypes.totalDatas) {
      return true
    }
    if (currentFeatures.varTypes.totalIntArrs > providedFeatures.varTypes.totalIntArrs) {
      return true
    }
    if (currentFeatures.varTypes.totalDecArrs > providedFeatures.varTypes.totalDecArrs) {
      return true
    }
    if (currentFeatures.varTypes.totalBoolArrs > providedFeatures.varTypes.totalBoolArrs) {
      return true
    }
    if (currentFeatures.varTypes.totalCharArrs > providedFeatures.varTypes.totalCharArrs) {
      return true
    }
    if (currentFeatures.varTypes.totalDataArrs > providedFeatures.varTypes.totalDataArrs) {
      return true
    }
    if (currentFeatures.varTypes.totalObjs > providedFeatures.varTypes.totalObjs) {
      return true
    }
    if (currentFeatures.varTypes.totalObjArrs > providedFeatures.varTypes.totalObjArrs) {
      return true
    }
    if (currentFeatures.varTypes.totalFuncArrs > providedFeatures.varTypes.totalFuncArrs) {
      return true
    }
    if (currentFeatures.totalAssignments > providedFeatures.totalAssignments) {
      return true
    }
    if (rejectAssignments(currentFeatures.asmtTypes, providedFeatures.asmtTypes)) {
      /* rejectedBranches += 1 */
      /* output.print("REJECTED assignments! linesRemaining: $(iu.intToString(linesRemaining))") */
      return true
    }
    if (currentFeatures.totalWhiles > providedFeatures.totalWhiles) {
      return true
    }
    if (currentFeatures.totalIfs > providedFeatures.totalIfs) {
      return true
    }
    /* if (currentFeatures.highestNestingLevel > providedFeatures.highestNestingLevel) {
      return true
    } */
    return false
  }

  // Compute the total distance between two vectors.
  int distanceBetweenVectors(PIFixed lhs, PIFixed rhs) {
    int totalDistance
    totalDistance += differenceBetweenInts(lhs.totalLines, rhs.totalLines)
    totalDistance += differenceBetweenInts(lhs.blankLines, rhs.blankLines)//lhs.nonBlankLines, rhs.nonBlankLines)
    totalDistance += differenceBetweenInts(lhs.totalVars, rhs.totalVars)
    totalDistance += differenceBetweenInts(lhs.nonInputVars, rhs.nonInputVars)
    totalDistance += differenceBetweenInts(lhs.totalAssignments, rhs.totalAssignments)
    totalDistance += differenceBetweenInts(lhs.totalWhiles, rhs.totalWhiles)
    totalDistance += differenceBetweenInts(lhs.totalIfs, rhs.totalIfs)
    /* totalDistance += getAbsValue(lhs.totalFunctionCalls - rhs.totalFunctionCalls) */
    totalDistance += differenceBetweenInts(lhs.aveLoopLength, rhs.aveLoopLength)
    totalDistance += differenceBetweenInts(lhs.aveWhileLength, rhs.aveWhileLength)
    totalDistance += differenceBetweenInts(lhs.highestNestingLevel, rhs.highestNestingLevel)
    return totalDistance
  }

  bool FeatureBuilder:rejectBranch(PIFixed current, bool declarationsComplete, int linesRemaining) {
    bool minLinesToComplete = hasMinLinesToCompleteFeatures(current, linesRemaining)
    bool areFeaturesReachable = areFeaturesReachable(current, declarationsComplete, linesRemaining)
    bool rejectEarly = rejectEarly(current, linesRemaining)

	  printCount ++

    if (rejectEarly || !minLinesToComplete || !areFeaturesReachable)
    {
      rejectedBranches += 1

  	  if (printCount % PRINT_FREQ == 0)
  		  output.print("\r rejectedBranches: $(iu.intToString(rejectedBranches)), acceptedBranches: $(iu.intToString(acceptedBranches)), rejectedPrograms: $(iu.intToString(rejectedPrograms)), acceptedPrograms: $(iu.intToString(acceptedPrograms)), linesRemaining: $(iu.intToString(linesRemaining))")
      return true
    }
    else {
      acceptedBranches += 1

  	  if (printCount % PRINT_FREQ == 0)
  		  output.print("\r rejectedBranches: $(iu.intToString(rejectedBranches)), acceptedBranches: $(iu.intToString(acceptedBranches)), rejectedPrograms: $(iu.intToString(rejectedPrograms)), acceptedPrograms: $(iu.intToString(acceptedPrograms)), linesRemaining: $(iu.intToString(linesRemaining))")
      return false
    }
  }

  bool declarationsInCorrectOrder(PIFixed current) {
    bool canMoveOn = true
    if (providedFeatures.totalVars > current.totalVars) {
      if (providedFeatures.varTypes.totalInts > current.varTypes.totalInts) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalDecs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalDecs > current.varTypes.totalDecs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalBools > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalBools > current.varTypes.totalBools) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalChars > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalChars > current.varTypes.totalChars) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalDatas > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalDatas > current.varTypes.totalDatas) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalIntArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalIntArrs > current.varTypes.totalIntArrs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalDecArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalDecArrs > current.varTypes.totalDecArrs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalBoolArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalBoolArrs > current.varTypes.totalBoolArrs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalCharArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalCharArrs > current.varTypes.totalCharArrs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalDataArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalDataArrs > current.varTypes.totalDataArrs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalObjs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalObjs > current.varTypes.totalObjs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalObjArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalObjArrs > current.varTypes.totalObjArrs) {
        canMoveOn = false
      }
      if (!canMoveOn && (current.varTypes.totalFuncArrs > 0))
      {
        return false
      }
      else if (providedFeatures.varTypes.totalFuncArrs > current.varTypes.totalFuncArrs) {
        canMoveOn = false
      }
    }
    return true
  }

  bool correctDeclarations(PIFixed current) {
    if (providedFeatures.totalVars != current.totalVars) {
      return false
    }
    if (providedFeatures.varTypes.totalInts != current.varTypes.totalInts) {
      return false
    }
    if (providedFeatures.varTypes.totalDecs != current.varTypes.totalDecs) {
      return false
    }
    if (providedFeatures.varTypes.totalBools != current.varTypes.totalBools) {
      return false
    }
    if (providedFeatures.varTypes.totalChars != current.varTypes.totalChars) {
      return false
    }
    if (providedFeatures.varTypes.totalDatas != current.varTypes.totalDatas) {
      return false
    }
    if (providedFeatures.varTypes.totalIntArrs != current.varTypes.totalIntArrs) {
      return false
    }
    if (providedFeatures.varTypes.totalDecArrs != current.varTypes.totalDecArrs) {
      return false
    }
    if (providedFeatures.varTypes.totalBoolArrs != current.varTypes.totalBoolArrs) {
      return false
    }
    if (providedFeatures.varTypes.totalCharArrs != current.varTypes.totalCharArrs) {
      return false
    }
    if (providedFeatures.varTypes.totalDataArrs != current.varTypes.totalDataArrs) {
      return false
    }
    if (providedFeatures.varTypes.totalObjs != current.varTypes.totalObjs) {
      return false
    }
    if (providedFeatures.varTypes.totalObjArrs != current.varTypes.totalObjArrs) {
      return false
    }
    if (providedFeatures.varTypes.totalFuncArrs != current.varTypes.totalFuncArrs) {
      return false
    }
    return true
  }

  // Decide if the provided features are reachable from the current FV.
  // NOTE could update this to include the order of assignments made, eg. ints before bools.
  bool FeatureBuilder:areFeaturesReachable(PIFixed current, bool declarationsComplete, int linesRemaining) {
    if (providedFeatures == null) output.println("providedFeatures is null in areFeaturesReachable in FeatureBuilder")
    if (current == null) output.println("current FV is null in areFeaturesReachable in FeatureBuilder")
    if (!declarationsInCorrectOrder(current)) return false
    if (declarationsComplete && !correctDeclarations(current)) {
      // If declarations are finished, no more can be done, so check if all are correct.
      return false
    }
    /* if (providedFeatures.asmtTypes.literalValue != null && current.asmtTypes.literalValue != null && (current.asmtTypes.literalValue != providedFeatures.asmtTypes.literalValue)) {
      return false
    } */
    if ((providedFeatures.asmtTypes.litValues != null) && (current.asmtTypes.literalValue != null))
    {
      bool matchingValue = false
      for (int i = 0; i < providedFeatures.asmtTypes.litValues.arrayLength; i++)
      {
        //output.println("current value: $(current.asmtTypes.literalValue)")
        char providedLit[] = providedFeatures.asmtTypes.litValues[i].string
        if (providedLit == current.asmtTypes.literalValue) {
          //output.println("provided value: $(providedFeatures.asmtTypes.litValues[i].chars), current value: $(current.asmtTypes.literalValue)")
          matchingValue = true
        }
      }
      if (!matchingValue) return false
    }
    if ((providedFeatures.asmtTypes.opTypes != null) && (current.asmtTypes.opType != null))
    {
      bool matchingValue = false
      for (int i = 0; i < providedFeatures.asmtTypes.opTypes.arrayLength; i++)
      {
        //output.println("current value: $(current.asmtTypes.literalValue)")
        char providedOpType[] = providedFeatures.asmtTypes.opTypes[i].string
        if (providedOpType == current.asmtTypes.opType) {
          //output.println("provided value: $(providedFeatures.asmtTypes.litValues[i].chars), current value: $(current.asmtTypes.literalValue)")
          matchingValue = true
        }
      }
      if (!matchingValue) return false
    }
    if (linesRemaining == 0) {
      if (providedFeatures.totalAssignments > current.totalAssignments) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToLit > current.asmtTypes.totalVarToLit) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToVar > current.asmtTypes.totalVarToVar) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToInd > current.asmtTypes.totalVarToInd) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToField > current.asmtTypes.totalVarToField) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToData > current.asmtTypes.totalVarToData) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToObj > current.asmtTypes.totalVarToObj) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToArrConcat > current.asmtTypes.totalVarToArrConcat) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToArrClone > current.asmtTypes.totalVarToArrClone) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToDataClone > current.asmtTypes.totalVarToDataClone) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToFunc > current.asmtTypes.totalVarToFunc) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToGOFunc > current.asmtTypes.totalVarToGOFunc) {
        return false
      }
      if (providedFeatures.asmtTypes.totalVarToLOFunc > current.asmtTypes.totalVarToLOFunc) {
        return false
      }
    }
    return true
  }

  bool FeatureBuilder:isProgramSimilar(PIFixed features, int linesRemaining) {
    if (providedFeatures == null) output.println("providedFeatures is null in isProgramSimilar in FeatureBuilder")
    // If the features of the current node are similar enough to the provided feature vector, add it to tree.
    int proximityToProvidedProgram = distanceBetweenVectors(providedFeatures, features)

	printCount ++

    // move this to FeatureBuilder
    if (proximityToProvidedProgram <= maxDeviation) {
      acceptedPrograms += 1

	  if (printCount % PRINT_FREQ == 0)
		output.print("\r rejectedBranches: $(iu.intToString(rejectedBranches)), acceptedBranches: $(iu.intToString(acceptedBranches)), rejectedPrograms: $(iu.intToString(rejectedPrograms)), acceptedPrograms: $(iu.intToString(acceptedPrograms)), linesRemaining: $(iu.intToString(linesRemaining))")

      return true
    }
    else {
      rejectedPrograms += 1

	  if (printCount % PRINT_FREQ == 0)
		output.print("\r rejectedBranches: $(iu.intToString(rejectedBranches)), acceptedBranches: $(iu.intToString(acceptedBranches)), rejectedPrograms: $(iu.intToString(rejectedPrograms)), acceptedPrograms: $(iu.intToString(acceptedPrograms)), linesRemaining: $(iu.intToString(linesRemaining))")
      return false
    }
  }

  bool FeatureBuilder:programHasMinimumFeatures(PIFixed currentFeatures, int linesRemaining) {
    /* if (providedFeatures == null) output.println("providedFeatures is null in isProgramSimilar in FeatureBuilder")
    // If the features of the current node are similar enough to the provided feature vector, add it to tree.
    bool minFeatures = true
    //minFeatures = minFeatures && (providedFeatures.totalLines <= currentFeatures.totalLines)
    minFeatures = minFeatures && (providedFeatures.blankLines <= currentFeatures.blankLines)
    minFeatures = minFeatures && (providedFeatures.totalVars <= currentFeatures.totalVars)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalInts <= currentFeatures.varTypes.totalInts)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalDecs <= currentFeatures.varTypes.totalDecs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalBools <= currentFeatures.varTypes.totalBools)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalChars <= currentFeatures.varTypes.totalChars)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalDatas <= currentFeatures.varTypes.totalDatas)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalIntArrs <= currentFeatures.varTypes.totalIntArrs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalDecArrs <= currentFeatures.varTypes.totalDecArrs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalBoolArrs <= currentFeatures.varTypes.totalBoolArrs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalCharArrs <= currentFeatures.varTypes.totalCharArrs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalDataArrs <= currentFeatures.varTypes.totalDataArrs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalObjs <= currentFeatures.varTypes.totalObjs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalObjArrs <= currentFeatures.varTypes.totalObjArrs)
    minFeatures = minFeatures && (providedFeatures.varTypes.totalFuncArrs <= currentFeatures.varTypes.totalFuncArrs)
    //minFeatures = minFeatures && (providedFeatures.nonInputVars <= currentFeatures.nonInputVars)
    minFeatures = minFeatures && (providedFeatures.totalAssignments <= currentFeatures.totalAssignments)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToLit <= currentFeatures.asmtTypes.totalVarToLit) && (providedFeatures.asmtTypes.totalIndToLit <= currentFeatures.asmtTypes.totalIndToLit) && (providedFeatures.asmtTypes.totalDataToLit <= currentFeatures.asmtTypes.totalDataToLit)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToVar <= currentFeatures.asmtTypes.totalVarToVar) && (providedFeatures.asmtTypes.totalIndToVar <= currentFeatures.asmtTypes.totalIndToVar) && (providedFeatures.asmtTypes.totalDataToVar <= currentFeatures.asmtTypes.totalDataToVar)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToInd <= currentFeatures.asmtTypes.totalVarToInd) && (providedFeatures.asmtTypes.totalIndToInd <= currentFeatures.asmtTypes.totalIndToInd) && (providedFeatures.asmtTypes.totalDataToInd <= currentFeatures.asmtTypes.totalDataToInd)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToField <= currentFeatures.asmtTypes.totalVarToField) && (providedFeatures.asmtTypes.totalIndToField <= currentFeatures.asmtTypes.totalIndToField) && (providedFeatures.asmtTypes.totalDataToField <= currentFeatures.asmtTypes.totalDataToField)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToData <= currentFeatures.asmtTypes.totalVarToData) && (providedFeatures.asmtTypes.totalIndToData <= currentFeatures.asmtTypes.totalIndToData) && (providedFeatures.asmtTypes.totalDataToData <= currentFeatures.asmtTypes.totalDataToData)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToObj <= currentFeatures.asmtTypes.totalVarToObj) && (providedFeatures.asmtTypes.totalIndToObj <= currentFeatures.asmtTypes.totalIndToObj) && (providedFeatures.asmtTypes.totalDataToObj <= currentFeatures.asmtTypes.totalDataToObj)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToArrConcat <= currentFeatures.asmtTypes.totalVarToArrConcat) && (providedFeatures.asmtTypes.totalIndToArrConcat <= currentFeatures.asmtTypes.totalIndToArrConcat) && (providedFeatures.asmtTypes.totalDataToArrConcat <= currentFeatures.asmtTypes.totalDataToArrConcat)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToArrClone <= currentFeatures.asmtTypes.totalVarToArrClone) && (providedFeatures.asmtTypes.totalIndToArrClone <= currentFeatures.asmtTypes.totalIndToArrClone) && (providedFeatures.asmtTypes.totalDataToArrClone <= currentFeatures.asmtTypes.totalDataToArrClone)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToDataClone <= currentFeatures.asmtTypes.totalVarToDataClone) && (providedFeatures.asmtTypes.totalIndToDataClone <= currentFeatures.asmtTypes.totalIndToDataClone) && (providedFeatures.asmtTypes.totalDataToDataClone <= currentFeatures.asmtTypes.totalDataToDataClone)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToFunc <= currentFeatures.asmtTypes.totalVarToFunc) && (providedFeatures.asmtTypes.totalIndToFunc <= currentFeatures.asmtTypes.totalIndToFunc) && (providedFeatures.asmtTypes.totalDataToFunc <= currentFeatures.asmtTypes.totalDataToFunc)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToGOFunc <= currentFeatures.asmtTypes.totalVarToGOFunc) && (providedFeatures.asmtTypes.totalIndToGOFunc <= currentFeatures.asmtTypes.totalIndToGOFunc) && (providedFeatures.asmtTypes.totalDataToGOFunc <= currentFeatures.asmtTypes.totalDataToGOFunc)
    minFeatures = minFeatures && (providedFeatures.asmtTypes.totalVarToLOFunc <= currentFeatures.asmtTypes.totalVarToLOFunc) && (providedFeatures.asmtTypes.totalIndToLOFunc <= currentFeatures.asmtTypes.totalIndToLOFunc) && (providedFeatures.asmtTypes.totalDataToLOFunc <= currentFeatures.asmtTypes.totalDataToLOFunc)
    minFeatures = minFeatures && (providedFeatures.totalWhiles <= currentFeatures.totalWhiles)
    minFeatures = minFeatures && (providedFeatures.totalIfs <= currentFeatures.totalIfs)
    minFeatures = minFeatures && (providedFeatures.totalFunctionCalls <= currentFeatures.totalFunctionCalls)
    //totalDistance = getAbsValue(minFeatures && (providedFeatures.totalFunctionCalls - currentFeatures.totalFunctionCalls)
    // These features are probably not very useful...
    //minFeatures = minFeatures && (providedFeatures.aveLoopLength <= currentFeatures.aveLoopLength)
    //minFeatures = minFeatures && (providedFeatures.aveWhileLength <= currentFeatures.aveWhileLength)
    minFeatures = minFeatures && (providedFeatures.highestNestingLevel <= currentFeatures.highestNestingLevel)
    if (minFeatures) { */
      acceptedPrograms += 1
      output.print("\r rejectedBranches: $(iu.intToString(rejectedBranches)), acceptedBranches: $(iu.intToString(acceptedBranches)), rejectedPrograms: $(iu.intToString(rejectedPrograms)), acceptedPrograms: $(iu.intToString(acceptedPrograms)), linesRemaining: $(iu.intToString(linesRemaining))")
      return true
    /* }
    else {
      rejectedPrograms += 1
      output.print("\r rejectedBranches: $(iu.intToString(rejectedBranches)), acceptedBranches: $(iu.intToString(acceptedBranches)), rejectedPrograms: $(iu.intToString(rejectedPrograms)), acceptedPrograms: $(iu.intToString(acceptedPrograms)), linesRemaining: $(iu.intToString(linesRemaining))")
      return false
    } */
  }

  String[] getLineComponents(char line[]) {
    StringUtil stringUtil = new StringUtil()
    String tokens[] = stringUtil.explode(line, " ")
    return tokens
  }

  int differenceBetweenInts(int lhs, int rhs) {
    if (lhs == rhs) return 0
    else if (lhs < rhs) return rhs - lhs
    else return lhs - rhs
  }

  void printFeatures(PIFixed currentFeatures) {
    output.println("current vars: $(iu.intToString(currentFeatures.totalVars)), provided: $(iu.intToString(providedFeatures.totalVars))")
    output.println("current ints: $(iu.intToString(currentFeatures.varTypes.totalInts)), provided: $(iu.intToString(providedFeatures.varTypes.totalInts))")
    output.println("current decs: $(iu.intToString(currentFeatures.varTypes.totalDecs)), provided: $(iu.intToString(providedFeatures.varTypes.totalDecs))")
    output.println("current bools: $(iu.intToString(currentFeatures.varTypes.totalBools)), provided: $(iu.intToString(providedFeatures.varTypes.totalBools))")
    output.println("current chars: $(iu.intToString(currentFeatures.varTypes.totalChars)), provided: $(iu.intToString(providedFeatures.varTypes.totalChars))")
    output.println("current datas: $(iu.intToString(currentFeatures.varTypes.totalDatas)), provided: $(iu.intToString(providedFeatures.varTypes.totalDatas))")
    output.println("current int arrays: $(iu.intToString(currentFeatures.varTypes.totalIntArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalIntArrs))")
    output.println("current dec arrays: $(iu.intToString(currentFeatures.varTypes.totalDecArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalDecArrs))")
    output.println("current bool arrays: $(iu.intToString(currentFeatures.varTypes.totalBoolArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalBoolArrs))")
    output.println("current char arrays: $(iu.intToString(currentFeatures.varTypes.totalCharArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalCharArrs))")
    output.println("current data arrays: $(iu.intToString(currentFeatures.varTypes.totalDataArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalDataArrs))")
    output.println("current objects: $(iu.intToString(currentFeatures.varTypes.totalObjs)), provided: $(iu.intToString(providedFeatures.varTypes.totalObjs))")
    output.println("current object arrays: $(iu.intToString(currentFeatures.varTypes.totalObjArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalObjArrs))")
    output.println("current function arrays: $(iu.intToString(currentFeatures.varTypes.totalFuncArrs)), provided: $(iu.intToString(providedFeatures.varTypes.totalFuncArrs))")
  }

  PIFixed FeatureBuilder:copyFeatures(PIFixed features) {
    if (features == null) return null
    VariableTypes varTypesCopy = clone features.varTypes
    AssignmentTypes asmtTypesCopy = clone features.asmtTypes
    OperatorTypes opTypesCopy = clone features.opTypes
    /* asmtTypesCopy.literalValue = "5" */
    Stack rlibCopy = features.remainingLinesInBlock//.clone()
    PIFixed copy = new PIFixed(features.isValid, /*totalLines*/features.totalLines, /*blankLines*/features.blankLines, /*totalVars*/features.totalVars, /*varTypes*/varTypesCopy, /*nonInputVars*/features.nonInputVars, /*totalAssignments*/features.totalAssignments, /*asmtTypes*/asmtTypesCopy, /*totalOperations*/features.totalOperations, /*opTypes*/opTypesCopy, /*totalWhiles*/features.totalWhiles, /*totalIfs*/features.totalIfs, /*totalFunctionCalls*/features.totalFunctionCalls, /*totalReturns*/features.totalReturns, /*aveLoopLength*/features.aveLoopLength,
			/*aveWhileLength*/features.aveWhileLength, /*highestNestingLevel*/features.highestNestingLevel, /*remainingLinesInBlock*/rlibCopy, /*totalLoopLength*/features.totalLoopLength, /*totalWhileLength*/features.totalWhileLength, /*minimumLinesToComplete*/features.minimumLinesToComplete)

    return copy
  }

}
