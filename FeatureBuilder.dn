uses data.String
uses data.StringUtil
uses reflect.Type
uses data.adt.Stack
uses FunctionData
uses Generator

component provides FeatureBuilder requires data.adt.Stack, data.StringUtil, io.Output output, data.IntUtil intUtil {

  /* FeatureBuilder:FeatureBuilder()
    {
    } */

  // The maximum ammount features vectors can differ and still be considered similar.
  int maxDeviation

  char inputVarType[]

  FunctionData functionData

  PIFixed providedFeatures

  int acceptedPrograms
  int rejectedPrograms
  int acceptedBranches
  int rejectedBranches

  PIFixed FeatureBuilder:getNewFeatureVector() {
    PIFixed features = new PIFixed()
    features.varTypes = new VariableTypes()
    features.asmtTypes = new AssignmentTypes()
    features.remainingLinesInBlock = new Stack()
    return features
  }

  void FeatureBuilder:setMaxDeviation(int _maxDeviation) {
    maxDeviation = _maxDeviation
  }

  void FeatureBuilder:setProvidedFeatures(PIFixed _providedFeatures) {
    providedFeatures = _providedFeatures
  }

  void FeatureBuilder:setFunctionData(FunctionData _functionData) {
    functionData = _functionData
  }

  // get a new PIFixed feature vector for the current feature vector (of a node) plus the new line.
  // May be easier/make more sense to just pass a Node and get the feature vector from there.
  /* PIFixed FeatureBuilder:updateFeatureVector(PIFixed current, String newLine, String inputVarType) { */
  PIFixed FeatureBuilder:updateFeatureVector(PIFixed currentFeatures, int lineType, char newLine[], int subLinesCount, int decType, int asmtType) { //}, String inputVarType) {
    // Node node = clone newNode
    //FeatureVector current = node.features
    PIFixed features
    if (currentFeatures == null) features = getNewFeatureVector()
    else features = clone currentFeatures

    features.totalLines ++

    // blank line:
    if (newLine == null) {
      features.blankLines ++
      // Or return 0 or -1? Or throw exception?
      /* return null */
    }
    else { //(features.totalLines > 0) {
      // Non blank line
      features = doUpdate(features, lineType, newLine, subLinesCount, decType, asmtType)
    }

    return features
  }

  bool FeatureBuilder:hasMinLinesToCompleteFeatures(PIFixed current, int linesRemaining) { //}, int programLength) {
    //int currentLinesUsed = current.totalLines
    //int linesRemaining = programLength - currentLinesUsed
    int minRequired = 0
    if (current.totalVars < providedFeatures.totalVars) {
      minRequired += (providedFeatures.totalVars - current.totalVars)
    }
    if (current.totalAssignments < providedFeatures.totalAssignments) {
      minRequired += (providedFeatures.totalAssignments - current.totalAssignments)
      // Check each asmtType now:
    }
    if (current.totalWhiles < providedFeatures.totalWhiles) {
      minRequired += (providedFeatures.totalWhiles - current.totalWhiles) * 2 // Minimum lines to make a control block is 3 lines? or 4? 1) while statement, 2) opening brace, 3) line, 4) closing brace
    }
    if (current.totalIfs < providedFeatures.totalIfs) {
      minRequired += (providedFeatures.totalIfs - current.totalIfs) * 2 // Minimum lines to make a control block is 3 lines? or 4? 1) while statement, 2) opening brace, 3) line, 4) closing brace
    }
    return minRequired <= linesRemaining
  }

  bool rejectAssignments(AssignmentTypes currentAsmtTypes, AssignmentTypes provAsmtTypes) {
    bool rejectAsmts = false
    // LHS =
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToLit > provAsmtTypes.totalVarToLit) || (currentAsmtTypes.totalIndToLit > provAsmtTypes.totalIndToLit) || (currentAsmtTypes.totalDataToLit > provAsmtTypes.totalDataToLit)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToVar > provAsmtTypes.totalVarToVar) || (currentAsmtTypes.totalIndToVar > provAsmtTypes.totalIndToVar) || (currentAsmtTypes.totalDataToVar > provAsmtTypes.totalDataToVar)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToInd > provAsmtTypes.totalVarToInd) || (currentAsmtTypes.totalIndToInd > provAsmtTypes.totalIndToInd) || (currentAsmtTypes.totalDataToInd > provAsmtTypes.totalDataToInd)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToField > provAsmtTypes.totalVarToField) || (currentAsmtTypes.totalIndToField > provAsmtTypes.totalIndToField) || (currentAsmtTypes.totalDataToField > provAsmtTypes.totalDataToField)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToData > provAsmtTypes.totalVarToData) || (currentAsmtTypes.totalIndToData > provAsmtTypes.totalIndToData) || (currentAsmtTypes.totalDataToData > provAsmtTypes.totalDataToData)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToObj > provAsmtTypes.totalVarToObj) || (currentAsmtTypes.totalIndToObj > provAsmtTypes.totalIndToObj) || (currentAsmtTypes.totalDataToObj > provAsmtTypes.totalDataToObj)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToArrConcat > provAsmtTypes.totalVarToArrConcat) || (currentAsmtTypes.totalIndToArrConcat > provAsmtTypes.totalIndToArrConcat) || (currentAsmtTypes.totalDataToArrConcat > provAsmtTypes.totalDataToArrConcat)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToArrClone > provAsmtTypes.totalVarToArrClone) || (currentAsmtTypes.totalIndToArrClone > provAsmtTypes.totalIndToArrClone) || (currentAsmtTypes.totalDataToArrClone > provAsmtTypes.totalDataToArrClone)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToDataClone > provAsmtTypes.totalVarToDataClone) || (currentAsmtTypes.totalIndToDataClone > provAsmtTypes.totalIndToDataClone) || (currentAsmtTypes.totalDataToDataClone > provAsmtTypes.totalDataToDataClone)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToFunc > provAsmtTypes.totalVarToFunc) || (currentAsmtTypes.totalIndToFunc > provAsmtTypes.totalIndToFunc) || (currentAsmtTypes.totalDataToFunc > provAsmtTypes.totalDataToFunc)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToGOFunc > provAsmtTypes.totalVarToGOFunc) || (currentAsmtTypes.totalIndToGOFunc > provAsmtTypes.totalIndToGOFunc) || (currentAsmtTypes.totalDataToGOFunc > provAsmtTypes.totalDataToGOFunc)
    rejectAsmts = rejectAsmts || (currentAsmtTypes.totalVarToLOFunc > provAsmtTypes.totalVarToLOFunc) || (currentAsmtTypes.totalIndToLOFunc > provAsmtTypes.totalIndToLOFunc) || (currentAsmtTypes.totalDataToLOFunc > provAsmtTypes.totalDataToLOFunc)

    return rejectAsmts
  }

  bool FeatureBuilder:rejectEarly(PIFixed currentFeatures, int linesRemaining) {
    // NOTE: complete!
    bool minLinesToComplete = hasMinLinesToCompleteFeatures(currentFeatures, linesRemaining)
    if (!minLinesToComplete) {
      //output.println("minLinesToComplete: $(intUtil.intToString(minLinesToComplete)), linesRemaining: $(intUtil.intToString(linesRemaining))")
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true // cannot complete all features in the remaining lines, so reject program.
    }
    // Check if too many variables have been declared
    if (currentFeatures.totalVars > providedFeatures.totalVars) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.varTypes.totalInts > providedFeatures.varTypes.totalInts) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.varTypes.totalDecs > providedFeatures.varTypes.totalDecs) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.varTypes.totalBools > providedFeatures.varTypes.totalBools) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.varTypes.totalChars > providedFeatures.varTypes.totalChars) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.varTypes.totalDatas > providedFeatures.varTypes.totalDatas) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.totalAssignments > providedFeatures.totalAssignments) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (rejectAssignments(currentFeatures.asmtTypes, providedFeatures.asmtTypes)) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.totalWhiles > providedFeatures.totalWhiles) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.totalIfs > providedFeatures.totalIfs) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    if (currentFeatures.highestNestingLevel > providedFeatures.highestNestingLevel) {
      rejectedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    acceptedBranches ++
    output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
    return false
  }

  // Compute the total distance between two vectors.
  int distanceBetweenVectors(PIFixed lhs, PIFixed rhs) {
    int totalDistance
    totalDistance += differenceBetweenInts(lhs.totalLines, rhs.totalLines)
    totalDistance += differenceBetweenInts(lhs.blankLines, rhs.blankLines)//lhs.nonBlankLines, rhs.nonBlankLines)
    totalDistance += differenceBetweenInts(lhs.totalVars, rhs.totalVars)
    totalDistance += differenceBetweenInts(lhs.nonInputVars, rhs.nonInputVars)
    totalDistance += differenceBetweenInts(lhs.totalAssignments, rhs.totalAssignments)
    totalDistance += differenceBetweenInts(lhs.totalWhiles, rhs.totalWhiles)
    totalDistance += differenceBetweenInts(lhs.totalIfs, rhs.totalIfs)
    /* totalDistance += getAbsValue(lhs.totalFunctionCalls - rhs.totalFunctionCalls) */
    totalDistance += differenceBetweenInts(lhs.aveLoopLength, rhs.aveLoopLength)
    totalDistance += differenceBetweenInts(lhs.aveWhileLength, rhs.aveWhileLength)
    totalDistance += differenceBetweenInts(lhs.highestNestingLevel, rhs.highestNestingLevel)
    return totalDistance
  }

  // Decide if the provided features are reachable from the current FV.
  // NOTE could update this to include the order of assignments made, eg. ints before bools.
  bool FeatureBuilder:areFeaturesReachable(PIFixed current, bool declarationsComplete, int linesRemaining) {
    if (providedFeatures == null) output.println("providedFeatures is null in areFeaturesReachable in FeatureBuilder")
    if (current == null) output.println("current FV is null in areFeaturesReachable in FeatureBuilder")
    if (declarationsComplete || linesRemaining == 0) {
      /* if (providedFeatures.totalAssignments > current.totalAssignments) { */
      if (providedFeatures.totalVars > current.totalVars) {
        // Not enough declarations made, so not reachable.
        rejectedBranches ++
        output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
        return false
      }
      if (providedFeatures.varTypes.totalInts > current.varTypes.totalInts) {
        // Not enough assignments made, so not reachable.
        rejectedBranches ++
        output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
        return false
      }
      if (providedFeatures.varTypes.totalDecs > current.varTypes.totalDecs) {
        // Not enough assignments made, so not reachable.
        rejectedBranches ++
        output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
        return false
      }
      if (providedFeatures.varTypes.totalBools > current.varTypes.totalBools) {
        // Not enough assignments made, so not reachable.
        rejectedBranches ++
        output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
        return false
      }
      if (providedFeatures.varTypes.totalChars > current.varTypes.totalChars) {
        // Not enough assignments made, so not reachable.
        rejectedBranches ++
        output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
        return false
      }
      if (providedFeatures.varTypes.totalDatas > current.varTypes.totalDatas) {
        // Not enough assignments made, so not reachable.
        rejectedBranches ++
        output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
        return false
      }
      acceptedBranches ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    acceptedBranches ++
    output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
    return true
  }

  bool FeatureBuilder:isProgramSimilar(PIFixed features, int linesRemaining) {
    if (providedFeatures == null) output.println("providedFeatures is null in isProgramSimilar in FeatureBuilder")
    // If the features of the current node are similar enough to the provided feature vector, add it to tree.
    int proximityToProvidedProgram = distanceBetweenVectors(providedFeatures, features)
    // move this to FeatureBuilder
    if (proximityToProvidedProgram <= maxDeviation) {
      acceptedPrograms ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    else {
      rejectedPrograms ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return false
    }
  }

  bool FeatureBuilder:programHasMinimumFeatures(PIFixed currentFeatures, int linesRemaining) {
    if (providedFeatures == null) output.println("providedFeatures is null in isProgramSimilar in FeatureBuilder")
    // If the features of the current node are similar enough to the provided feature vector, add it to tree.
    bool minFeatures = true
    while (minFeatures == true) { // Save unneccasary computation if one of the features is not
      /* minFeatures = minFeatures && (providedFeatures.totalLines <= currentFeatures.totalLines) */
      /* minFeatures = minFeatures && (providedFeatures.nonBlankLines <= currentFeatures.nonBlankLines) */
      minFeatures = minFeatures && (providedFeatures.blankLines <= currentFeatures.blankLines)
      minFeatures = minFeatures && (providedFeatures.totalVars <= currentFeatures.totalVars)
      minFeatures = minFeatures && (providedFeatures.varTypes.totalInts <= currentFeatures.varTypes.totalInts)
      minFeatures = minFeatures && (providedFeatures.varTypes.totalDecs <= currentFeatures.varTypes.totalDecs)
      minFeatures = minFeatures && (providedFeatures.varTypes.totalBools <= currentFeatures.varTypes.totalBools)
      minFeatures = minFeatures && (providedFeatures.varTypes.totalChars <= currentFeatures.varTypes.totalChars)
      minFeatures = minFeatures && (providedFeatures.varTypes.totalDatas <= currentFeatures.varTypes.totalDatas)
      /* minFeatures = minFeatures && (providedFeatures.nonInputVars <= currentFeatures.nonInputVars) */
      minFeatures = minFeatures && (providedFeatures.totalAssignments <= currentFeatures.totalAssignments)
      minFeatures = minFeatures && (providedFeatures.totalWhiles <= currentFeatures.totalWhiles)
      minFeatures = minFeatures && (providedFeatures.totalIfs <= currentFeatures.totalIfs)
      /* totalDistance = getAbsValue(minFeatures && (providedFeatures.totalFunctionCalls - currentFeatures.totalFunctionCalls) */
      // These features are probably not very useful...
      /* minFeatures = minFeatures && (providedFeatures.aveLoopLength <= currentFeatures.aveLoopLength)
      minFeatures = minFeatures && (providedFeatures.aveWhileLength <= currentFeatures.aveWhileLength) */
      minFeatures = minFeatures && (providedFeatures.highestNestingLevel <= currentFeatures.highestNestingLevel)
      acceptedPrograms ++
      output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
      return true
    }
    rejectedPrograms ++
    output.print("\r rejectedBranches: $(intUtil.intToString(rejectedBranches)), acceptedBranches: $(intUtil.intToString(acceptedBranches)), rejectedPrograms: $(intUtil.intToString(rejectedPrograms)), acceptedPrograms: $(intUtil.intToString(acceptedPrograms)), lineCount: $(intUtil.intToString(linesRemaining))")
    return false
  }

  String[] getLineComponents(char line[]) {
    StringUtil stringUtil = new StringUtil()
    String tokens[] = stringUtil.explode(line, " ")
    return tokens
  }

  /* update the assignment type counts */
  AssignmentTypes updateAssignmentTypes(AssignmentTypes asmtTypes, int asmtType) {
    if (asmtType == 1) asmtTypes.totalVarToLit ++
    else if (asmtType == 2) asmtTypes.totalVarToVar ++
    else if (asmtType == 3) asmtTypes.totalVarToInd ++
    else if (asmtType == 4) asmtTypes.totalVarToField ++
    else if (asmtType == 5) asmtTypes.totalVarToData ++
    else if (asmtType == 6) asmtTypes.totalVarToObj ++
    else if (asmtType == 7) asmtTypes.totalVarToArrConcat ++
    else if (asmtType == 8) asmtTypes.totalVarToArrClone ++
    else if (asmtType == 9) asmtTypes.totalVarToDataClone ++
    else if (asmtType == 10) asmtTypes.totalVarToFunc ++
    else if (asmtType == 11) asmtTypes.totalVarToGOFunc ++
    else if (asmtType == 12) asmtTypes.totalVarToLOFunc ++
    // LHS = variable indices
    else if (asmtType == 13) asmtTypes.totalVarToLit ++
    else if (asmtType == 14) asmtTypes.totalVarToVar ++
    else if (asmtType == 15) asmtTypes.totalVarToInd ++
    else if (asmtType == 16) asmtTypes.totalVarToField ++
    else if (asmtType == 17) asmtTypes.totalVarToData ++
    else if (asmtType == 18) asmtTypes.totalVarToObj ++
    else if (asmtType == 19) asmtTypes.totalVarToArrConcat ++
    else if (asmtType == 20) asmtTypes.totalVarToArrClone ++
    else if (asmtType == 21) asmtTypes.totalVarToDataClone ++
    else if (asmtType == 22) asmtTypes.totalVarToFunc ++
    else if (asmtType == 23) asmtTypes.totalVarToGOFunc ++
    else if (asmtType == 24) asmtTypes.totalVarToLOFunc ++
    // LHS = data
    else if (asmtType == 25) asmtTypes.totalVarToLit ++
    else if (asmtType == 26) asmtTypes.totalVarToVar ++
    else if (asmtType == 27) asmtTypes.totalVarToInd ++
    else if (asmtType == 28) asmtTypes.totalVarToField ++
    else if (asmtType == 29) asmtTypes.totalVarToData ++
    else if (asmtType == 30) asmtTypes.totalVarToObj ++
    else if (asmtType == 31) asmtTypes.totalVarToArrConcat ++
    else if (asmtType == 32) asmtTypes.totalVarToArrClone ++
    else if (asmtType == 33) asmtTypes.totalVarToDataClone ++
    else if (asmtType == 34) asmtTypes.totalVarToFunc ++
    else if (asmtType == 35) asmtTypes.totalVarToGOFunc ++
    else if (asmtType == 36) asmtTypes.totalVarToLOFunc ++

    return asmtTypes
  }

  // NOTE: If function overloading is possible, have separate functions for each type of FeatureVector (when more than PIFixed is available!)
  /* FeatureVector doUpdate(Node currentNode) { */
  PIFixed doUpdate(PIFixed currentFeatures, int lineType, char newLine[], int subLinesCount, int decType, int asmtType) {
    //Node node = clone currentNode
    PIFixed update = currentFeatures //node.features
    /* update.nonBlankLines ++ */
    //Operation lineInfo = node.lineInfo
    String tokens[] = getLineComponents(newLine)
    // Check if we are currently within a subscope:
    if (update.remainingLinesInBlock.getLength() != 0) {
      LineInfo lineInfo = update.remainingLinesInBlock.peek()
      if (lineInfo.linesRemaining == 0) {
        update.remainingLinesInBlock.remove(update.remainingLinesInBlock.peek())
      }
      if (update.remainingLinesInBlock.getLength() != 0) {
        //int updatedCount = update.remainingLinesInBlock.peek().linesRemaining - 1 // make a copy of top value and update it
        lineInfo = update.remainingLinesInBlock.peek()
        lineInfo.linesRemaining -= 1
        update.remainingLinesInBlock.update(update.remainingLinesInBlock.peek(), lineInfo)
        /* update.remainingLinesInBlock.add(updatedCount) // replace with updated value */
      }
    }
    if (lineType == 0) {
      // 0 = local variable call
      update.totalFunctionCalls ++
    }
    else if (lineType == 1) {
      // 1 = declaration
      update.totalVars ++
      /* if (tokens[0] == inputVarType) {
        update.nonInputVars ++
      } */
      VariableTypes vts = update.varTypes
      if (decType == 1) vts.totalInts ++
      else if (decType == 2) vts.totalDecs ++
      else if (decType == 3) vts.totalChars ++
      else if (decType == 4) vts.totalBools ++
      else if (decType == 5) vts.totalDatas ++
      update.varTypes = vts
    }
    else if (lineType == 2) {
      // 2 = assignment - we could increase the number of assignment types
      update.totalAssignments ++
      update.asmtTypes = updateAssignmentTypes(update.asmtTypes, asmtType)
    }
    else if (lineType == 3) {
      // 3 = if statement
      update.totalIfs ++
      // update average if statement length
      update.totalLoopLength += subLinesCount
      update.aveLoopLength = update.totalLoopLength / update.totalIfs
      // Update control block nesting info
      LineInfo nextCount = new LineInfo(subLinesCount)
      update.remainingLinesInBlock.add(nextCount)
      // Check if current nesting level is greater than previous maximum, if so, update maximum
      if (update.remainingLinesInBlock.getLength() > update.highestNestingLevel) {
        update.highestNestingLevel = update.remainingLinesInBlock.getLength()
      }
    }
    else if (lineType == 4) {
      // 4 = while loop
      update.totalWhiles ++
      // Update average while loop length
      update.totalWhileLength += subLinesCount
      update.aveWhileLength = update.totalWhileLength / update.totalWhiles
      // Update control block nesting info
      LineInfo nextCount = new LineInfo(subLinesCount)
      update.remainingLinesInBlock.add(nextCount)
      // Check if current nesting level is greater than previous maximum, if so, update maximum
      if (update.remainingLinesInBlock.getLength() > update.highestNestingLevel) {
        update.highestNestingLevel = update.remainingLinesInBlock.getLength()
      }

    }
    else if (lineType == 5) {
      // 5 = return
      update.totalReturns ++
    }
    return update
  }
/*
    String[] tokens = getLineComponents
    /* if (tokens.arrayLength == 1) {
      // One token, must be either { or }, so signals a nesting level
      if (tokens[0] == '{') {
        current.openBrackets ++
        if (current.openBrackets > current.highestNestingLevel) {
          // If current nesting level is greater than highest, update it
          current.highestNestingLevel = current.openBrackets
        }
      }
      else {
        // Closing bracket, reduce current nesting level
        current.openBrackets -= 1
      }
    } */
    /* // 2 tokens is a declaration or control block
    else if (tokens.arrayLength == 2) {
      // If first token is a type, then it is a declaration
      // NOTE: This can be done in buildNextLine in Generator.dn
      if (tokens[0] == "int" || tokens[0] == "dec" || tokens[0] == "char" || tokens[0] == "bool") {
        update.totalVars ++
        if (tokens[0] == inputVarType) {
          update.nonInputVars ++
        }
      }
      // Else check if a control block
      else if (tokens[0] == "if") {
        update.totalIfs ++
      }
      else if (tokens[0] == "while") {
         update.totalWhiles ++
      } */
      /* else {
        // Must be a return statement
        // NOTE: what would be appropriate here, if anything?
      } */
    /* }
    // -- Not a declaration or control block --
    else if (tokens.arrayLength >= 3) {
      // 3 tokens is assignment
      if (tokens[1] == "=") {
        // Assignment statement
        if (tokens.arrayLength == 3) {
          if (tokens[0] != tokens[2]) {
            update.totalVarInteractions ++
          }
        }
        else if (tokens.arrayLength == 5) {
          if (tokens[0] != tokens[2] && tokens[2] != tokens[4] && tokens[0] != tokens[4]) {
            update.totalVarInteractions += 3
          }
          else if (tokens[0] != tokens[2] || tokens[2] != tokens[4]) {
            update.totalVarInteractions += 2
          }
          else {
            update.totalVarInteractions ++
          }
        }
      }
    }
    return update
  }  */

  int differenceBetweenInts(int lhs, int rhs) {
    if (lhs == rhs) return 0
    else if (lhs < rhs) return rhs - lhs
    else return lhs - rhs
  }

}
