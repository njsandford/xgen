uses data.String
uses data.StringUtil
uses reflect.Type
uses data.adt.Stack
uses FunctionData
uses Generator

component provides FeatureBuilder requires data.adt.Stack, data.StringUtil {

  /* FeatureBuilder:FeatureBuilder()
    {
    } */

  // The maximum ammount features vectors can differ and still be considered similar.
  int maxDeviation

  char inputVarType[]

  FunctionData functionData

  FeatureVector providedFeatures

  PIFixed FeatureBuilder:getNewFeatureVector() {
    PIFixed features = new PIFixed()
    features.totalLines = 0 // This might be better as nonBlankLines, and have a separate value for program length?
    features.nonBlankLines = 0
    features.totalVars = 0
    features.nonInputVars = 0
    features.totalAssignments = 0
    features.totalWhiles = 0
    features.totalIfs = 0
    features.totalFunctionCalls = 0
    features.totalReturns = 0
    features.aveLoopLenth = 0
    features.aveControlBlockLength = 0
    features.highestNestingLevel = 0
    features.remainingLinesInBlock = new Stack()
    return features
  }

  void FeatureBuilder:setMaxDeviation(int _maxDeviation) {
    maxDeviation = _maxDeviation
  }

  void FeatureBuilder:setProvidedFeatures(PIFixed _providedFeatures) {
    providedFeatures = _providedFeatures
  }

  void FeatureBuilder:setFunctionData(FunctionData _functionData) {
    functionData = _functionData
  }

  // get a new PIFixed feature vector for the current feature vector (of a node) plus the new line.
  // May be easier/make more sense to just pass a Node and get the feature vector from there.
  /* PIFixed FeatureBuilder:updateFeatureVector(PIFixed current, String newLine, String inputVarType) { */
  PIFixed FeatureBuilder:updateFeatureVector(PIFixed currentFeatures, char newLine[], int subLinesCount) { //}, String inputVarType) {
    // Node node = clone newNode
    //FeatureVector current = node.features
    if (newLine == null) {
      // Or return 0 or -1? Or throw exception?
      return null
    }
    if (currentFeatures == null) {
      currentFeatures = getNewFeatureVector()
    }

    currentFeatures.totalLines += 1
    if (currentFeatures.totalLines > 0) {
      // Non blank line
      currentFeatures = doUpdate(currentFeatures, newLine, subLinesCount)
    }

    return currentFeatures
  }

  // Compute the total distance between two vectors.
  int FeatureBuilder:distanceBetweenVectors(PIFixed lhs, PIFixed rhs) {
    int totalDistance
    totalDistance += getAbsValue(lhs.totalLines - rhs.totalLines)
    totalDistance += getAbsValue(lhs.nonBlankLines - rhs.nonBlankLines)
    totalDistance += getAbsValue(lhs.totalVars - rhs.totalVars)
    totalDistance += getAbsValue(lhs.nonInputVars - rhs.nonInputVars)
    totalDistance += getAbsValue(lhs.totalAssignments - rhs.totalAssignments)
    totalDistance += getAbsValue(lhs.totalWhiles - rhs.totalWhiles)
    totalDistance += getAbsValue(lhs.totalIfs - rhs.totalIfs)
    totalDistance += getAbsValue(lhs.totalFunctionCalls - rhs.totalFunctionCalls)
    /* totalDistance += getAbsValue(lhs.aveLoopLenth - rhs.aveLoopLenth)
    totalDistance += getAbsValue(lhs.aveControlBlockLength - rhs.aveControlBlockLength) */
    totalDistance += getAbsValue(lhs.highestNestingLevel - rhs.highestNestingLevel)
    return totalDistance
  }

  // Decide if the provided features are reachable from the current FV.
  // NOTE could update this to include the order of assignments made, eg. ints before bools.
  bool FeatureBuilder:areFeaturesReachable(PIFixed provided, PIFixed current, bool declarationsComplete) {
    if (declarationsComplete) {
      if (provided.totalAssignments > current.totalAssignments) {
        // Not enough assignments made, so not reachable.
        return false
      }
      else return true
    }
    return true
  }

  bool FeatureBuilder:isProgramSimilar(PIFixed features) {
    // If the features of the current node are similar enough to the provided feature vector, add it to tree.
    int proximityToProvidedProgram = distanceBetweenVectors(providedFeatures, features)
    // move this to FeatureBuilder
    if (proximityToProvidedProgram <= maxDeviation) {
      return true
    }
    else return false
  }

  String[] getLineComponents(char line[]) {
    StringUtil stringUtil = new StringUtil()
    String tokens[] = stringUtil.explode(line, " ")
    return tokens
  }

  // NOTE: If function overloading is possible, have separate functions for each type of FeatureVector (when more than PIFixed is available!)
  /* FeatureVector doUpdate(Node currentNode) { */
  PIFixed doUpdate(PIFixed currentFeatures, char newLine[], int subLinesCount) {
    //Node node = clone currentNode
    PIFixed update = currentFeatures //node.features
    //Operation lineInfo = node.lineInfo
    String tokens[] = getLineComponents()
    // Check if we are currently within a subscope:
    if (update.remainingLinesInBlock.getLength() != 0) {
      if (update.remainingLinesInBlock.peek() == 0) {
        update.remainingLinesInBlock.remove(update.remainingLinesInBlock.peek())
      }
      if (update.remainingLinesInBlock.getLength() != 0) {
        int updatedCount = update.remainingLinesInBlock.peek() - 1 // make a copy of top value and update it
        update.remainingLinesInBlock.remove(update.remainingLinesInBlock.peek())
        update.remainingLinesInBlock.add(updatedCount) // replace with updated value
      }
    }
    if (lineType == 0) {
      // 0 = local variable call
      update.totalFunctionCalls += 1
    }
    else if (lineType == 1) {
      // 1 = declaration
      if (tokens[0] == inputVarType) {
        update.nonInputVars += 1
      }
    }
    else if (lineType == 2) {
      // 2 = assignment - we could increase the number of assignment types
      update.totalAssignments += 1
    }
    else if (lineType == 3) {
      // 3 = if statement
      update.totalIfs += 1
      update.remainingLinesInBlock.add(subLinesCount)
      // Check if current nesting level is greater than previous maximum, if so, update maximum
      if (update.remainingLinesInBlock.getLength() > update.highestNestingLevel) {
        update.highestNestingLevel = update.getLength()
      }
    }
    else if (lineType == 4) {
      // 4 = while loop
      update.totalWhiles += 1
      update.remainingLinesInBlock.add(subLinesCount)
      // Check if current nesting level is greater than previous maximum, if so, update maximum
      if (update.remainingLinesInBlock.getLength() > update.highestNestingLevel) {
        update.highestNestingLevel = update.getLength()
      }

    }
    else if (lineType == 5) {
      // 5 = return
      update.totalReturns += 1
    }
    return update
  }
/*
    String[] tokens = getLineComponents
    /* if (tokens.arrayLength == 1) {
      // One token, must be either { or }, so signals a nesting level
      if (tokens[0] == '{') {
        current.openBrackets += 1
        if (current.openBrackets > current.highestNestingLevel) {
          // If current nesting level is greater than highest, update it
          current.highestNestingLevel = current.openBrackets
        }
      }
      else {
        // Closing bracket, reduce current nesting level
        current.openBrackets -= 1
      }
    } */
    /* // 2 tokens is a declaration or control block
    else if (tokens.arrayLength == 2) {
      // If first token is a type, then it is a declaration
      // NOTE: This can be done in buildNextLine in Generator.dn
      if (tokens[0] == "int" || tokens[0] == "dec" || tokens[0] == "char" || tokens[0] == "bool") {
        update.totalVars += 1
        if (tokens[0] == inputVarType) {
          update.nonInputVars += 1
        }
      }
      // Else check if a control block
      else if (tokens[0] == "if") {
        update.totalIfs += 1
      }
      else if (tokens[0] == "while") {
         update.totalWhiles += 1
      } */
      /* else {
        // Must be a return statement
        // NOTE: what would be appropriate here, if anything?
      } */
    /* }
    // -- Not a declaration or control block --
    else if (tokens.arrayLength >= 3) {
      // 3 tokens is assignment
      if (tokens[1] == "=") {
        // Assignment statement
        if (tokens.arrayLength == 3) {
          if (tokens[0] != tokens[2]) {
            update.totalVarInteractions += 1
          }
        }
        else if (tokens.arrayLength == 5) {
          if (tokens[0] != tokens[2] && tokens[2] != tokens[4] && tokens[0] != tokens[4]) {
            update.totalVarInteractions += 3
          }
          else if (tokens[0] != tokens[2] || tokens[2] != tokens[4]) {
            update.totalVarInteractions += 2
          }
          else {
            update.totalVarInteractions += 1
          }
        }
      }
    }
    return update
  }  */

  int getAbsValue(int number) {
    if (number < 0) {
      number = 0 - number
    }
    return number
  }

}
