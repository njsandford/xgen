//NOTE: could separate the "clock hands" concept into a utility component...

uses reflect.Type
uses FeatureBuilder

const byte XTYPE_VAR = 100

data DataType {
	char name[]
	char package[]
	Type type
}

//224 bytes each
data Node extends Option
{
	int inScope[]
	SearchScope subLines[]
	bool declarationsComplete // Very useful for feature building: can do a check that enough/not too many variables exist to make the FV reachable.
	bool blankLines
	Operation lineInfo // Stores information about the current line for this node
	PIFixed features
}

data PermutationSet {
	int totalLines
	int globalLines
	int limit
	int found
	Node nodes[]
	Node nextNode
}

data GlobalAPI {
	char name[]
	DataType t
}

data SearchScope {
	Node root
	int subLinesCount
	int subLinesStart
	Node options[]
}

data Variable {
	char name[]
	int typeIndex
}

data Assignment {
	char line[]
	int asmtType
}

/* NOTE: I think this represents a single line of a program? */
data Operation {
	Variable newVar // NOTE: What is this? Variable declaration?
	char line[]
	int lineType // The type of line this is: [0=local var call], 1=declaration, 2=assignment(NOTE: could have 2 types of assignment, e.g. a = b, and a = b + c), 3=if, 4=while, 5=return
	int subLinesCount
	int decType // declaration type, integer between 1 and 6 representing [int, dec, bool, char, void, Data]
	int asmtType // assignment type, integer between 1 and 24
}

// NOTE:
data ParamOptions {
	String options[]
}

data ClockHand {
	int current
	int max
}

data ScopeStackItem {
	int ins[]
	int remainingLines
	int totalLines
	ScopeStackItem next
}

data Function {
	char name[]
	Type returnType
	Type parameters[]
}

const int HOST_INT_SIZE = 8
const int HOST_DEC_SIZE = 16

component provides Generator requires io.Output out, data.IntUtil iu, data.StringUtil stringUtil, data.query.Search search, io.FileSystem fileSystem, io.File, os.SystemInfo sysInfo, doc.DocBuilder {

	DataType types[] = new DataType[](
		new DataType("int", null, new Type(Type.INTEGER, 0, HOST_INT_SIZE)),
		new DataType("dec", null, new Type(Type.DECIMAL, 0, HOST_DEC_SIZE)),
		new DataType("char", null, new Type(Type.INTEGER, Type.F_CHAR, 1)),
		new DataType("bool", null, new Type(Type.INTEGER, Type.F_BOOL, 1)),
		new DataType("Data", null, new Type(Type.DATA, 0, 0)),
		new DataType("void", null, new Type(Type.INTEGER, 0, 0))
		)

		Function functions[]

		Function operators[]

		GlobalAPI globalObjects[]
		GlobalAPI instantiableObjects[]

		char providedInterfaceType[]

		String searchDirectories[]

		Generator:Generator(String searchPaths[])
		{
			addArrayTypes()

			searchDirectories = searchPaths

			addResource("Object")

			addCoreFunctions()
		}

		void Generator:setProvidedInterface(char type[])
		{
			providedInterfaceType = type

			addResource(type)
		}

		void addArrayTypes()
		{
			for (int i = 0; i < types.arrayLength; i++)
			{
				if (types[i].type.class != Type.ARRAY)
				{
					types = new DataType[]( types, new DataType("$(types[i].name)[]", types[i].package, new Type( Type.ARRAY, 0, 0, new Field[](new Field(types[i].type)) ) ) )
				}
			}
		}

		void addArrayType(DataType t)
		{
			if (t.type.class != Type.ARRAY)
			{
				types = new DataType[]( types, new DataType("$(t.name)[]", t.package, new Type( Type.ARRAY, 0, 0, new Field[](new Field(t.type)) ) ) )
			}
		}

		void addCoreFunctions()
		{
			Function nf

			nf = new Function("+", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("*", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("/", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("-", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("%", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("+", getType("dec").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("*", getType("dec").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("/", getType("dec").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("-", getType("dec").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("|", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("&", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("^", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("~", getType("int").type, new Type[](getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("<<", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function(">>", getType("int").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("===", getType("bool").type, new Type[](getType("Object").type, getType("Object").type))
			operators = new Function[](operators, nf)

			nf = new Function("!==", getType("bool").type, new Type[](getType("Object").type, getType("Object").type))
			operators = new Function[](operators, nf)

			nf = new Function("===", getType("bool").type, new Type[](getType("Data").type, getType("Data").type))
			operators = new Function[](operators, nf)

			nf = new Function("!==", getType("bool").type, new Type[](getType("Data").type, getType("Data").type))
			operators = new Function[](operators, nf)

			nf = new Function(">", getType("bool").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("<", getType("bool").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function(">=", getType("bool").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function("<=", getType("bool").type, new Type[](getType("int").type, getType("int").type))
			operators = new Function[](operators, nf)

			nf = new Function(">", getType("bool").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("<", getType("bool").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function(">=", getType("bool").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("<=", getType("bool").type, new Type[](getType("dec").type, getType("dec").type))
			operators = new Function[](operators, nf)

			nf = new Function("!", getType("bool").type, new Type[](getType("bool").type))
			operators = new Function[](operators, nf)

			//NOTE: the parameters of this are really "<t>", where <t> must be compatible across the two parameters
			nf = new Function("==", getType("bool").type, new Type[](new Type(XTYPE_VAR), new Type(XTYPE_VAR)))
			operators = new Function[](operators, nf)

			nf = new Function("!=", getType("bool").type, new Type[](new Type(XTYPE_VAR), new Type(XTYPE_VAR)))
			operators = new Function[](operators, nf)
		}

		bool isParamLinkedOperator(Function f)
		{
			if (f.name == "=="
			|| f.name == "!=")
			return true

			return false
		}

		char[] findPackage(String searchPaths[], char p[])
		{
			char test[] = stringUtil.implode(stringUtil.explode(p, "."), "/")
			test = new char[](test, ".dn")

			if (fileSystem.exists(test))
			return test

			//try search paths
			for (int i = 0; i < searchPaths.arrayLength; i++)
			{
				char result[] = new char[](searchPaths[i].string, "/resources/", test)

				out.println("test: '$result'")

				if (fileSystem.exists(result))
				{
					return result
				}
			}

			//try central source tree
			char result[] = new char[](sysInfo.getVariable("DANA_HOME"), "/resources/", test)

			out.println("test: '$result'")

			if (fileSystem.exists(result))
			return result

			return null
		}

		Type makeFunctionType(FunctionDef fd)
		{
			Type t = new Type(Type.FUNCTION)

			//out.println(" - RT. $(fd.returnType)")

			t.fields = new Field[](t.fields, new Field(getType(fd.returnType).type, null))

			for (int i = 0; i < fd.params.arrayLength; i++)
			{
				//out.println(" - PT. $(fd.params[i].type) $(fd.params[i].displayName)")

				char fname[] = fd.params[i].displayName
				bool array = stringUtil.find(fname, "[]") != StringUtil.NOT_FOUND

				if (array)
				{
					fname = stringUtil.subString(fname, 0, stringUtil.find(fname, "[]"))
					t.fields = new Field[](t.fields, new Field(getType(new char[](fd.params[i].type, "[]")).type, fname))
				}
				else
				{
					t.fields = new Field[](t.fields, new Field(getType(fd.params[i].type).type, fd.params[i].name))
				}
			}

			return t
		}

		void populateTypeStructure(DataType t, TypeDef source)
		{
			//build the type structure of "t" from the type structure of "source", including all sub-fields
			// - and flatten inheritance hierarchies
			// - also "size" types, by knowing that "int2" is of size 2 etc.

			// - type class
			if (source.class == TypeDef.INTEGER)
			t.type.class = Type.INTEGER
			else if (source.class == TypeDef.DECIMAL)
			t.type.class = Type.DECIMAL
			else if (source.class == TypeDef.DATA)
			t.type.class = Type.DATA
			else if (source.class == TypeDef.OBJECT)
			t.type.class = Type.OBJECT

			// - size (TODO)
			if (source.name == "int")
			t.type.size = HOST_INT_SIZE
			else if (source.name == "dec")
			t.type.size = HOST_DEC_SIZE
			//etc.

			// - fields
			if (source.class == TypeDef.DATA)
			{
				DataDef dd = source

				for (int i = 0; i < dd.fields.arrayLength; i++)
				{
					t.type.fields = new Field[](t.type.fields, new Field(getType(dd.fields[i].type).type, dd.fields[i].name))
				}

				//TODO traverse super-types, if any
			}
			else if (source.class == TypeDef.OBJECT)
			{
				InterfaceDef dd = source

				for (int i = 0; i < dd.functions.arrayLength; i++)
				{
					out.println(" -- function $(dd.functions[i].name)")
					t.type.fields = new Field[](t.type.fields, new Field(makeFunctionType(dd.functions[i]), dd.functions[i].name))
				}

				//TODO traverse super-types, if any
			}
		}

		void addGlobalObject(DataType t)
		{
			int n = globalObjects.arrayLength
			char vn[] = "gv_$(iu.intToString(n))"

			globalObjects = new GlobalAPI[](globalObjects, new GlobalAPI(vn, t))
		}

		void addInstantiableObject(DataType dt)
		{
			instantiableObjects = new GlobalAPI[](instantiableObjects, new GlobalAPI(dt.name, dt))
		}

		char[] makeNewLine(Operation op)
		{
			return op.line
		}

		DataType getType(char name[])
		{
			//TODO: need GC-CRCs for this:
			//DataType res[] = search.search(types, DataType.[name], new DataType(name))

			for (int i = 0; i < types.arrayLength; i++)
			{
				if (types[i].name == name)
				return types[i]
			}

			return null

			/*
			if (res != null)
			return res[0]
			else
			return null
			*/
		}

		char[] getTypeName(Type t)
		{
			for (int i = 0; i < types.arrayLength; i++)
			{
				if (types[i].type === t)
				return types[i].name
			}

			return null
		}

		int getTypeIndex(Type t)
		{
			for (int i = 0; i < types.arrayLength; i++)
			{
				if (types[i].type === t)
				return i
			}

			return INT_MAX
		}

		//TODO: handle type recursion
		//note: this function is how a compile-time type check works; an "equivalent" runtime type check may still fail & cause an exception
		// - note this check assumes that "a" is the thing being assigned *into*, from "b" (this "direction" is important)
		bool typesCompatible(Type a, Type b)
		{
			if (a === b)
			return true

			if (a.class != b.class)
			{
				return false
			}
			else
			{
				if (a.class == Type.ARRAY)
				{
					a = a.fields[0].type
					b = b.fields[0].type

					if (!typesMatch(a, b))
					return false
					else
					return true
				}
				else if (a.class == Type.DATA)
				{
					//field counts don't have to match, since the variable might be set to a subtype at runtime
					// - however, for any fields that *are* here, they must exactly match
					for (int i = 0; i < a.fields.arrayLength && i < b.fields.arrayLength; i++)
					{
						if (!typesMatch(a.fields[i].type, b.fields[i].type))
						{
							return false
						}
					}
				}
				else if (a.class == Type.OBJECT)
				{
					for (int i = 0; i < a.fields.arrayLength && i < b.fields.arrayLength; i++)
					{
						if (!typesMatch(a.fields[i].type, b.fields[i].type))
						{
							return false
						}
					}
				}
				else if (a.class == Type.INTEGER)
				{
					//we make a special case for booleans, saying that they can't be assigned to anything but a boolean
					// - humans can do this, if they know what they're doing, but in general a bool is restricted to 0 or 1
					if (a.flags == Type.F_BOOL && b.flags != Type.F_BOOL)
					return false
				}
			}

			return true
		}

		//TODO: handle type recursion
		bool typesMatch(Type a, Type b)
		{
			if (a === b)
			return true

			if (a.class != b.class)
			{
				return false
			}
			else
			{
				if (a.class == Type.ARRAY)
				{
					a = a.fields[0].type
					b = b.fields[0].type

					if (!typesMatch(a, b))
					return false
					else
					return true
				}

				if (a.class == Type.INTEGER)
				{
					if (a.size != b.size)
					return false

					if (a.flags == Type.F_BOOL && b.flags != Type.F_BOOL)
					return false
				}
				else if (a.class == Type.DECIMAL)
				{
					if (a.size != b.size)
					return false
				}
				else if (a.class == Type.DATA || a.class == Type.OBJECT || a.class == Type.FUNCTION)
				{
					//field counts must exactly match, as must field contents
					if (a.fields.arrayLength != b.fields.arrayLength)
					return false

					for (int i = 0; i < a.fields.arrayLength; i++)
					{
						if (!typesMatch(a.fields[i].type, b.fields[i].type))
						{
							return false
						}
					}
				}
			}

			return true
		}

		/* NOTE: very useful method to get the name of the variable without [] */
		char[] getCleanTypeName(char n[])
		{
			if (stringUtil.find(n, "[]") != StringUtil.NOT_FOUND)
			{
				n = stringUtil.subString(n, 0, stringUtil.find(n, "[]"))
			}

			return n
		}

		Operation[] generateDeclarations(int ins[])
		{
			Operation result[]

			//one of each available type, starting from ins end
			int si = 0

			if (ins != null)
			{
				si = ins[ins.arrayLength-1]
			}

			for (int i = si; i < types.arrayLength; i++)
			{
				if (types[i].name != "void" && types[i].name != "void[]" && types[i].name != providedInterfaceType)
				{
					char name[] = "locv_$(iu.intToString(ins.arrayLength))"

					int typeNumber = 0 // start actual types at 1 incase there are addtional types which would leave typeNumber as 0 by default.
					if (types[i].name == "int") typeNumber = 1
					else if (types[i].name == "dec") typeNumber = 2
					else if (types[i].name == "char") typeNumber = 3
					else if (types[i].name == "bool") typeNumber = 4
					else if (types[i].name == "Data") typeNumber = 5
					else if (types[i].name == "int[]") typeNumber = 6
					else if (types[i].name == "dec[]") typeNumber = 7
					else if (types[i].name == "char[]") typeNumber = 8
					else if (types[i].name == "bool[]") typeNumber = 9
					else if (types[i].name == "Data[]") typeNumber = 10
					else if (types[i].name == "Object") typeNumber = 11
					else if (types[i].name == "Object[]") typeNumber = 12
					else if (types[i].name == "$(providedInterfaceType)[]") typeNumber = 13
					else typeNumber = 0

					Operation newOp
					if (types[i].type.class == Type.ARRAY)
					newOp = new Operation(new Variable(name, i), "$(getCleanTypeName(types[i].name)) $(name)[]", 1, 0, typeNumber)
					else
					newOp = new Operation(new Variable(name, i), "$(getCleanTypeName(types[i].name)) $name", 1, 0, typeNumber)

					result = new Operation[](result, newOp)
				}
			}

			return result
		}

		Assignment[] getValidLiterals(Type t, int asmtType)
		{
			//String result[]
			Assignment result[]

			if (t.class == Type.INTEGER && t.flags == Type.F_BOOL)
			{
				result = new Assignment[](result, new Assignment("true", asmtType))
				result = new Assignment[](result, new Assignment("false", asmtType))
			}
			else if (t.class == Type.INTEGER)
			{
				result = new Assignment[](result, new Assignment("0", asmtType))
				result = new Assignment[](result, new Assignment("1", asmtType))
				result = new Assignment[](result, new Assignment("2", asmtType))
				result = new Assignment[](result, new Assignment("3", asmtType))
				result = new Assignment[](result, new Assignment("4", asmtType))
				result = new Assignment[](result, new Assignment("5", asmtType))
				result = new Assignment[](result, new Assignment("6", asmtType))
				result = new Assignment[](result, new Assignment("7", asmtType))
				result = new Assignment[](result, new Assignment("8", asmtType))
				result = new Assignment[](result, new Assignment("9", asmtType))
				result = new Assignment[](result, new Assignment("10", asmtType)) // is this needed?
			}
			else if (t.class == Type.DECIMAL)
			{
				result = new Assignment[](result, new Assignment("0.0", asmtType))
				result = new Assignment[](result, new Assignment("0.1", asmtType))
				result = new Assignment[](result, new Assignment("0.2", asmtType))
				result = new Assignment[](result, new Assignment("0.3", asmtType))
				result = new Assignment[](result, new Assignment("0.4", asmtType))
				result = new Assignment[](result, new Assignment("0.5", asmtType))
				result = new Assignment[](result, new Assignment("0.6", asmtType))
				result = new Assignment[](result, new Assignment("0.7", asmtType))
				result = new Assignment[](result, new Assignment("0.8", asmtType))
				result = new Assignment[](result, new Assignment("0.9", asmtType))
				result = new Assignment[](result, new Assignment("1.0", asmtType)) // is this needed?
			}

			return result
		}

		Assignment[] getValidVariables(int ins[], Type t, int asmtType)
		{
			Assignment result[]

			for (int i = 0; i < ins.arrayLength; i++)
			{
				if (typesCompatible(t, types[ins[i]].type))
				{
					result = new Assignment[](result, new Assignment("locv_$(iu.intToString(i))", asmtType))
				}
			}

			return result
		}

		Assignment[] getValidVariableIndices(int ins[], Type t, int asmtType)
		{
			Assignment result[]

			for (int i = 0; i < ins.arrayLength; i++)
			{
				if (types[ins[i]].type.class == Type.ARRAY
					&& typesCompatible(t, types[ins[i]].type.fields[0].type))
					{
						//find every variable we can use to index into it
						for (int j = 0; j < ins.arrayLength; j++)
						{
							if (typesMatch(types[ins[j]].type, getType("int").type))
							{
								result = new Assignment[](result, new Assignment("locv_$(iu.intToString(i))[locv_$(iu.intToString(j))]", asmtType))
							}
						}
					}
				}

				return result
			}

			Assignment[] getValidVariableFields(int ins[], Type t, int asmtType)
			{
				Assignment result[]

				for (int i = 0; i < ins.arrayLength; i++)
				{
					if (types[ins[i]].type.class == Type.DATA)
					{
						//find every variable we can use to index into it
						for (int j = 0; j < types[ins[i]].type.fields.arrayLength; j++)
						{
							if (typesCompatible(t, types[ins[i]].type.fields[j].type))
							{
								result = new Assignment[](result, new Assignment("locv_$(iu.intToString(i)).$(types[ins[i]].type.fields[j].name)", asmtType))
							}
						}
					}
				}

				return result
			}

			Assignment[] getValidArrayConcatenations(int ins[], Type t, int asmtType)
			{
				Assignment result[]

				if (t.class == Type.ARRAY)
				{
					//find any two variables to concatenate
					// - they can either be two arrays of compatible types, or can be an array and a non-array of compatible types

					for (int i = 0; i < ins.arrayLength; i++)
					{
						for (int j = 0; j < ins.arrayLength; j++)
						{
							//although assignment of arrays needs an exact type match, concatenation only needs element-level compatibility

							Type typeA = types[ins[i]].type
							Type typeB = types[ins[j]].type

							if (typeA.class == Type.ARRAY)
							typeA = typeA.fields[0].type

							if (typeB.class == Type.ARRAY)
							typeB = typeB.fields[0].type

							if (typesCompatible(t, typeA) && typesCompatible(t, typeB) && typesCompatible(typeA, typeB))
							{
								char tname[] = getTypeName(t)
								result = new Assignment[](result, new Assignment("new $(tname)[](locv_$(iu.intToString(i)), locv_$(iu.intToString(j)))", asmtType))
							}
						}
					}
				}

				return result
			}

			String[] getParameterOptions(int ins[], Type t)
			{
				//TODO: just all variables and literals, plus constants from any types...maybe also .arrayLength ?
				String result[]

				for (int i = 0; i < ins.arrayLength; i++)
				{
					if (typesCompatible(t, types[ins[i]].type))
					{
						result = new String[](result, new String("locv_$(iu.intToString(i))"))
					}
				}

				//result = new String[](result, getValidLiterals(t)) //TODO???

				return result
			}

			bool clockFinished(ClockHand hands[])
			{
				//return true if all hands are at "max"

				for (int i = 0; i < hands.arrayLength; i++)
				{
					if (hands[i].current != hands[i].max)
					return false
				}

				return true
			}

			void getNextClockPosition(ClockHand hands[])
			{
				int i = 0

				while (hands[i].current == hands[i].max)
				i ++

				hands[i].current ++

				i --
				while (i != INT_MAX)
				{
					hands[i].current = 0
					i --
				}
			}

			char[] getFunctionCallOption(Function f, ParamOptions params[], ClockHand hands[])
			{
				char functionCall[] = f.name

				functionCall = new char[](functionCall, "(")

				for (int i = 0; i < hands.arrayLength; i++)
				{
					if (i != 0)
					functionCall = new char[](functionCall, ",")

					functionCall = new char[](functionCall, params[i].options[hands[i].current].string)
				}

				functionCall = new char[](functionCall, ")")

				return functionCall
			}

			char[] getOperatorOption(Function f, ParamOptions params[], ClockHand hands[])
			{
				char functionCall[]

				if (params.arrayLength == 1)
				{
					functionCall = "$(f.name) $(params[0].options[hands[0].current].string)"
				}
				else if (params.arrayLength == 2)
				{
					functionCall = "$(params[0].options[hands[0].current].string) $(f.name) $(params[1].options[hands[1].current].string)"
				}

				return functionCall
			}

			Assignment[] getFunctionVariants(int ins[], Function f, char prefix[], int asmtType)
			{
				//out.println("generating variants for $prefix -- $(f.name)")

				Assignment result[]

				if (f.parameters.arrayLength == 0)
				return new String("$prefix$(f.name)()")

				ParamOptions params[] = new ParamOptions[f.parameters.arrayLength]

				for (int i = 0; i < params.arrayLength; i++)
				{
					params[i] = new ParamOptions()

					params[i].options = getParameterOptions(ins, f.parameters[i])

					if (params[i].options == null) return null
				}

				//create an array of "clock hands", where each hand has a current value and a max. value
				ClockHand hands[] = new ClockHand[f.parameters.arrayLength]

				for (int i = 0; i < hands.arrayLength; i++)
				{
					hands[i] = new ClockHand(0, params[i].options.arrayLength - 1)
				}

				char functionCall[] = getFunctionCallOption(f, params, hands)
				result = new Assignment[](result, new Assignment("$prefix$functionCall", asmtType))

				while (!clockFinished(hands))
				{
					getNextClockPosition(hands)

					functionCall = getFunctionCallOption(f, params, hands)
					result = new Assignment[](result, new Assignment("$prefix$functionCall", asmtType))
				}

				return result
			}

			Assignment[] getOperatorVariants(int ins[], Function f, int asmtType)
			{
				//out.println("generating variants for $prefix -- $(f.name)")

				Assignment result[]

				if (f.parameters.arrayLength == 0)
				return new String("$(f.name)")

				ParamOptions params[] = new ParamOptions[f.parameters.arrayLength]

				if (isParamLinkedOperator(f))
				{
					//here, the operator takes parameters that are of any type, but all parameters must be of equivalent type
					// - so we iterate through all known types, and see if we can fill parameters of that type

					for (int n = 0; n < types.arrayLength; n++)
					{
						bool fail = false

						for (int i = 0; i < params.arrayLength; i++)
						{
							params[i] = new ParamOptions()

							params[i].options = getParameterOptions(ins, types[n].type)

							if (params[i].options == null)
							{
								fail = true
								break
							}
						}

						if (!fail)
						{
							//create an array of "clock hands", where each hand has a current value and a max. value
							ClockHand hands[] = new ClockHand[f.parameters.arrayLength]

							for (int i = 0; i < hands.arrayLength; i++)
							{
								hands[i] = new ClockHand(0, params[i].options.arrayLength - 1)
							}

							char functionCall[] = getOperatorOption(f, params, hands)

							//for <t> parameters, it's possible to re-use the exact same call if a parameter matches multiple types
							// - here we just check that we're not repeating a selected option
							if (search.search(result, String.[string], new String(functionCall)) == null)
							result = new Assignment[](result, new Assignment(functionCall, asmtType))

							while (!clockFinished(hands))
							{
								getNextClockPosition(hands)

								functionCall = getOperatorOption(f, params, hands)

								if (search.search(result, String.[string], new String(functionCall)) == null)
								result = new Assignment[](result, new Assignment(functionCall, asmtType))
							}
						}
					}
				}
				else
				{
					for (int i = 0; i < params.arrayLength; i++)
					{
						params[i] = new ParamOptions()

						params[i].options = getParameterOptions(ins, f.parameters[i])

						if (params[i].options == null) return null
					}

					//create an array of "clock hands", where each hand has a current value and a max. value
					ClockHand hands[] = new ClockHand[f.parameters.arrayLength]

					for (int i = 0; i < hands.arrayLength; i++)
					{
						hands[i] = new ClockHand(0, params[i].options.arrayLength - 1)
					}

					char functionCall[] = getOperatorOption(f, params, hands)
					result = new Assignment[](result, new Assignment(functionCall, asmtType))

					while (!clockFinished(hands))
					{
						getNextClockPosition(hands)

						functionCall = getOperatorOption(f, params, hands)
						result = new Assignment[](result, new Assignment(functionCall, asmtType))
					}
				}

				return result
			}

			Assignment[] getValidFunctionCalls(int ins[], Type t, int asmtType)
			{
				Assignment result[]

				// - iterate through every variable that we have; for each one iterate through all function calls with a compatible return type
				//   - for each of these, we iterate through every possible variable for each parameter of the function
				for (int j = 0; j < functions.arrayLength; j++)
				{
					if (typesCompatible(t, functions[j].returnType))
					{
						//generate a version of this function call with every possible parameter variant
						result = new Assignment[](result, getFunctionVariants(ins, functions[j], "", asmtType))
					}
				}

				for (int j = 0; j < operators.arrayLength; j++)
				{
					if (typesCompatible(t, operators[j].returnType))
					{
						//generate a version of this operator with every possible parameter variant
						result = new Assignment[](result, getOperatorVariants(ins, operators[j], asmtType))
					}
				}

				//add all .arrayLength operations
				if (typesCompatible(t, getType("int").type))
				{
					for (int i = 0; i < ins.arrayLength; i++)
					{
						if (types[ins[i]].type.class == Type.ARRAY)
						{
							result = new Assignment[](result, new Assignment("locv_$(iu.intToString(i)).arrayLength", asmtType))
						}
					}
				}

				return result
			}

			Function functionFromType(char name[], Type t)
			{
				Function f = new Function(name, t.fields[0].type)

				for (int i = 1; i < t.fields.arrayLength; i++)
				{
					f.parameters = new Type[](f.parameters, t.fields[i].type)
				}

				return f
			}

			Assignment[] getValidGlobalObjectFunctionCalls(int ins[], Type t, int asmtType)
			{
				Assignment result[]

				// - iterate through every variable that we have; for each one iterate through all function calls with a compatible return type
				//   - for each of these, we iterate through every possible variable for each parameter of the function
				for (int j = 0; j < globalObjects.arrayLength; j++)
				{
					for (int k = 0; k < globalObjects[j].t.type.fields.arrayLength; k++)
					{
						Type ft = globalObjects[j].t.type.fields[k].type

						if (typesCompatible(t, ft.fields[0].type))
						{
							//generate a version of this function call with every possible parameter variant
							Function fnc = functionFromType(globalObjects[j].t.type.fields[k].name, ft)

							Assignment newOps[] = getFunctionVariants(ins, fnc, "$(globalObjects[j].name).", asmtType)

							result = new Assignment[](result, newOps)
						}
					}
				}

				return result
			}

			Assignment[] getValidLocalObjectFunctionCalls(int ins[], Type t, int asmtType)
			{
				Assignment result[]

				// - iterate through every variable that we have; for each one iterate through all function calls with a compatible return type
				//   - for each of these, we iterate through every possible variable for each parameter of the function
				for (int j = 0; j < ins.arrayLength; j++)
				{
					if (types[ins[j]].type.class == Type.OBJECT)
					{
						for (int k = 0; k < types[ins[j]].type.fields.arrayLength; k++)
						{
							Type ft = types[ins[j]].type.fields[k].type

							if (t == null || typesCompatible(t, ft.fields[0].type))
							{
								//generate a version of this function call with every possible parameter variant
								Function fnc = functionFromType(types[ins[j]].type.fields[k].name, ft)

								Assignment newOps[] = getFunctionVariants(ins, fnc, "locv_$(iu.intToString(j)).", asmtType)

								result = new Assignment[](result, newOps)
							}
						}
					}
				}

				return result
			}

			Assignment[] getValidDataInstantiations(Type t, int asmtType)
			{
				//TODO: we could allow instantiation of any sub-type of "t"...?

				Assignment result[]

				if (t.class == Type.DATA)
				{
					result = new Assignment[](result, new Assignment("new $(getTypeName(t))()", asmtType))
				}

				return result
			}

			Assignment[] getValidObjectInstantiations(int ins[], Type t, int asmtType)
			{
				//TODO: we could allow instantiation of any sub-type of "t"...?

				Assignment result[]

				if (t.class == Type.OBJECT)
				{
					//this explicitly needs a "required" interface to have been declared
					char tname[] = getTypeName(t)

					//TODO: need GC-CRCs to do the below...
					/*
					GlobalAPI x[] = search.search(instantiableObjects, GlobalAPI.[name], new GlobalAPI(tname))

					if (x != null)
					{
					//enumerate every possible way of calling the constructor
					Field cf = search.search(t.fields, Field.[name], new Field(null, tname))[0]

					Function fnc = functionFromType(cf.name, cf.type)

					result = new String[](result, getFunctionVariants(ins, fnc, "new "))
				}
				*/

				GlobalAPI candidate

				for (int i = 0; i < instantiableObjects.arrayLength; i++)
				{
					if (instantiableObjects[i].name == tname)
					{
						candidate = instantiableObjects[i]
						break
					}
				}

				if (candidate != null)
				{
					Type conType

					for (int i = 0; i < t.fields.arrayLength; i++)
					{
						if (t.fields[i].name == tname)
						{
							conType = t.fields[i].type
							break
						}
					}

					Function fnc = functionFromType(tname, conType)

					result = new Assignment[](result, getFunctionVariants(ins, fnc, "new ", asmtType))
				}
			}

			return result
		}

		Assignment[] getValidArrayClones(int ins[], Type t, int asmtType)
		{
			Assignment result[]

			if (t.class == Type.ARRAY)
			{
				for (int i = 0; i < ins.arrayLength; i++)
				{
					if (types[ins[i]].type.class == Type.ARRAY && typesMatch(t, types[ins[i]].type))
					{
						result = new Assignment[](result, new Assignment("clone locv_$(iu.intToString(i))", asmtType))
					}
				}
			}

			return result
		}

		Assignment[] getValidDataClones(int ins[], Type t, int asmtType)
		{
			Assignment result[]

			//NOTE: in this case we can actually do sub-type cloning...?
			if (t.class == Type.DATA)
			{
				for (int i = 0; i < ins.arrayLength; i++)
				{
					if (types[ins[i]].type.class == Type.DATA && typesMatch(t, types[ins[i]].type))
					{
						result = new Assignment[](result, new Assignment("clone locv_$(iu.intToString(i))", asmtType))
					}
				}
			}

			return result
		}

		/* creates a string array of all possible valid assignments */
		/* creates an assignment array of all possible valid assignments */
	//	String[] getValidAssignments(int ins[], Type t)
		Assignment[] getValidAssignments(int ins[], Type t)
		{
			//String result[]
			Assignment result[]

			//from literal values
			//result = new String[](result, getValidLiterals(t))
			result = new Assignment[](result, getValidLiterals(t, 1))

			//from variables
			//result = new String[](result, getValidVariables(ins, t))
			result = new Assignment[](result, getValidVariables(ins, t, 2))


			//from array indices of variables
			//result = new String[](result, getValidVariableIndices(ins, t))
			result = new Assignment[](result, getValidVariableIndices(ins, t, 3))

			//from fields of variables
			//result = new String[](result, getValidVariableFields(ins, t))
			result = new Assignment[](result, getValidVariableFields(ins, t, 4))

			//from new instantiations of data types
			//result = new String[](result, getValidDataInstantiations(t))
			result = new Assignment[](result, getValidDataInstantiations(t, 5))

			//from new instantiations of object types
			//result = new String[](result, getValidObjectInstantiations(ins, t))
			result = new Assignment[](result, getValidObjectInstantiations(ins, t, 6))

			//from new instantiations of array types by size, using available integer sizes (TODO)

			//from concatenations of arrays
			//result = new String[](result, getValidArrayConcatenations(ins, t))
			result = new Assignment[](result, getValidArrayConcatenations(ins, t, 7))

			//from cloned arrays / data
			//result = new String[](result, getValidArrayClones(ins, t))
			result = new Assignment[](result, getValidArrayClones(ins, t, 8))
			//result = new String[](result, getValidDataClones(ins, t))
			result = new Assignment[](result, getValidDataClones(ins, t, 9))

			//from function call results (including pseudo-functions representing operators)
			//result = new String[](result, getValidFunctionCalls(ins, t))
			result = new Assignment[](result, getValidFunctionCalls(ins, t, 10))

			//from object call results, from any in-scope objects (global/local)
			//result = new String[](result, getValidGlobalObjectFunctionCalls(ins, t))
			result = new Assignment[](result, getValidGlobalObjectFunctionCalls(ins, t, 11))
			//result = new String[](result, getValidLocalObjectFunctionCalls(ins, t))
			result = new Assignment[](result, getValidLocalObjectFunctionCalls(ins, t, 12))

			return result
		}

		Operation[] generateAssignments(int ins[])
		{
			Operation result[]

			//search for all things that can assign into one of our in-scope variables
			// -- (or TO or FROM an index of an array variable, where the index is from X)
			// -- including data types, where we can assign to/from their fields

			//scan every variable, and get everything of a matching type we could assign it to
			for (int i = 0; i < ins.arrayLength; i++)
			{
			//	String options[] = getValidAssignments(ins, types[ins[i]].type)
				Assignment options[] = getValidAssignments(ins, types[ins[i]].type)

				for (int j = 0; j < options.arrayLength; j++)
				{
					//result = new Operation[](result, new Operation(null, "locv_$(iu.intToString(i)) = $(options[j].line.string)", 2))
					result = new Operation[](result, new Operation(null, "locv_$(iu.intToString(i)) = $(options[j].line)", 2, 0, 0, options[j].asmtType))
				}
			}

			//then scan every array, and get everything we could assign an index to
			for (int i = 0; i < ins.arrayLength; i++)
			{
				if (types[ins[i]].type.class == Type.ARRAY)
				{
					Type subtype = types[ins[i]].type.fields[0].type

					//String options[] = getValidAssignments(ins, subtype)
					Assignment options[] = getValidAssignments(ins, subtype)


					for (int j = 0; j < options.arrayLength; j++)
					{
						//find every array index option to assign this to, by finding all "int" variables

						for (int k = 0; k < ins.arrayLength; k++)
						{
							if (typesMatch(getType("int").type, types[ins[k]].type))
							{
								//result = new Operation[](result, new Operation(null, "locv_$(iu.intToString(i))[locv_$(iu.intToString(k))] = $(options[j].string)", 2))
								result = new Operation[](result, new Operation(null, "locv_$(iu.intToString(i))[locv_$(iu.intToString(k))] = $(options[j].line)", 2, 0, 0, (12 + options[j].asmtType)))
							}
						}
					}
				}
			}

			//then scan every data type, and get everything we could assign each of its fields to
			for (int i = 0; i < ins.arrayLength; i++)
			{
				if (types[ins[i]].type.class == Type.DATA)
				{
					for (int n = 0; n < types[ins[i]].type.fields.arrayLength; n++)
					{
						Type subtype = types[ins[i]].type.fields[n].type

						//String options[] = getValidAssignments(ins, subtype)
						Assignment options[] = getValidAssignments(ins, subtype)

						for (int j = 0; j < options.arrayLength; j++)
						{
							//result = new Operation[](result, new Operation(null, "locv_$(iu.intToString(i)).$(types[ins[i]].type.fields[n].name) = $(options[j].string)", 2))
							result = new Operation[](result, new Operation(null, "locv_$(iu.intToString(i)).$(types[ins[i]].type.fields[n].name) = $(options[j].line)", 2, 0, 0, (24 + options[j].asmtType)))
						}
					}
				}
			}

			return result
		}

		Operation[] generateLocalObjectCalls(int ins[])
		{
			Operation result[]

			Assignment options[] = getValidLocalObjectFunctionCalls(ins, null, 12)

			for (int j = 0; j < options.arrayLength; j++)
			{
				result = new Operation[](result, new Operation(null, "$(options[j].line)", 0)) // NOTE: should a local object call be given a line type? can it be a single line?
			}

			return result
		}

		Operation[] generateReturns(int ins[], char returnType[])
		{
			Operation result[]

			Type rt = getType(returnType).type

			for (int i = 0; i < ins.arrayLength; i++)
			{
				if (typesCompatible(types[ins[i]].type, rt))
				{
					result = new Operation[](result, new Operation(null, "return locv_$(iu.intToString(i))", 5))
				}
			}

			return result
		}

		Operation[] generateControlBlocks(int ins[], int remainingLines)
		{
			Operation result[]

			if (remainingLines <= 1)
			return null

			Type boolType = getType("bool").type

			for (int i = 0; i < ins.arrayLength; i++)
			{
				if (typesMatch(boolType, types[ins[i]].type))
				{
					//generate every control flow block for every line length

					// - if statements
					for (int j = 1; j < remainingLines; j++)
					{
						result = new Operation[](result, new Operation(null, "if (locv_$(iu.intToString(i)))", 3, j))
					}

					// - while loops
					for (int j = 1; j < remainingLines; j++)
					{
						result = new Operation[](result, new Operation(null, "while (locv_$(iu.intToString(i)))", 4, j))
					}

					//NOTE: we may want to add " == false" versions too...
				}
			}

			return result
		}

		Operation[] generateOperations(int ins[], int remainingLines, bool noDeclarations, bool blank, bool outerScope)
		{
			Operation result[]

			if (!blank)
			{
				//all declarations of new variables, of every possible type
				if (!noDeclarations)
				result = new Operation[](result, generateDeclarations(ins))

				//all assignments of any in-scope variable to X (where X is any in-scope variable, or any function call, or any literal from a subsampled set of options)
				// - function parameters will need every option from X, up to a max. nesting depth
				result = new Operation[](result, generateAssignments(ins))

				//all function calls on objects (not using their return values)
				result = new Operation[](result, generateLocalObjectCalls(ins))

				//all return options (TODO)

				//all calls of local functions (TODO)

				//all control flow blocks, using X (boolean) in its header, of every possible length from 1 to (max_lines - here)
				result = new Operation[](result, generateControlBlocks(ins, remainingLines))
			}

			//blank lines (note, there's no point creating these for sub-scopes, as these are already length-controlled separately)
			if (outerScope) result = new Operation[](result, new Operation(null, null, 0))

			return result
		}

		// NOTE: convert operations to nodes -- modify this! could a node include an operation?
		// Maybe this is where the feature builder should be called to build features for each node? (instead of in buildLines)
		Node[] buildNextLine(Node n, int remainingLines, bool outerScope, FeatureBuilder featureBuilder) // , FeatureVector features) // Add the featureVector to compare current program to.
		{
			Node result[]

			Operation ops[] = generateOperations(n.inScope, remainingLines, n.declarationsComplete, n.blankLines, outerScope)

			for (int j = 0; j < ops.arrayLength; j++)
			{
				char newLine[] = makeNewLine(ops[j]) // NOTE: This is the string line of code!

				int newins[]

				/* New inscope variables */
				if (ops[j].newVar == null)
				newins = n.inScope
				else
				newins = new int[](n.inScope, ops[j].newVar.typeIndex)

				SearchScope newss[]

				if (ops[j].subLinesCount > 0) {
					newss = new SearchScope[](n.subLines, new SearchScope(new Node(null, newins), ops[j].subLinesCount))
					//newlt = // This indicates that it is a control block?
				}
				else {
					newss = n.subLines
				}

				/* Node newNode = clone n */
				Node newNode = new Node()
				newNode.lines = n.lines
				newNode.declarationsComplete = n.declarationsComplete
				newNode.blankLines = n.blankLines
				newNode.inScope = newins
				newNode.subLines = newss
				newNode.lineInfo = ops[j] // Pass the current operation to the new node
				//lineInfo.line = newLine // Added this to be used by feature builder.
				//lineInfo.lineType = newlt // Added lineType var for feature builder
				/* newNode.features = clone n.features//featureBuilder.updateFeatureVector(newNode.features, ops[j].lineType, ops[j].line, ops[j].lineType, ops[j].decType, ops[j].asmtType) */
				/* newNode.features = clone n.features
				if (n.features != null) {
					newNode.features.varTypes = clone n.features.varTypes
					newNode.features.asmtTypes = clone n.features.asmtTypes
				} */
				newNode.features = featureBuilder.copyFeatures(n.features)
				/* newNode.features.remainingLinesInBlock = clone n.features.remainingLinesInBlock */

				if (ops[j].newVar == null) {
					newNode.declarationsComplete = true
				}
				if (ops[j].line == null) {
					newNode.blankLines = true // this could also be a count of all blank lines, where a value > 0 is equivalent to 'true'.
				}

				result = new Node[](result, newNode)
			}

			return result
		}

		Node[] buildReturns(Node n, char returnType[])
		{
			Node result[]

			Operation ops[] = generateReturns(n.inScope, returnType)

			for (int j = 0; j < ops.arrayLength; j++)
			{
				char newLine[] = makeNewLine(ops[j])

				int newins[]

				if (ops[j].newVar == null)
				newins = n.inScope
				else
				newins = new int[](n.inScope, ops[j].newVar.typeIndex)

				SearchScope newss[]

				if (ops[j].subLinesCount > 0)
				newss = new SearchScope[](n.subLines, new SearchScope(new Node(null, newins), ops[j].subLinesCount))
				else
				newss = n.subLines

				Node newNode = new Node(null, newins)
				newNode.subLines = newss
				newNode.lineInfo = ops[j]
				result = new Node[](result, newNode)
			}

			return result
		}

		Node[] removeFirstCells(Node of[], int count)
		{
			if (count == 0) return of

			int remainder = of.arrayLength - count
			Node result[] = new Node[remainder]

			for (int i = 0; i < remainder; i++)
			{
				result[i] = of[count+i]
			}

			return result
		}

		int[] removeFirstIntCells(int of[], int count)
		{
			if (count == 0) return of

			int remainder = of.arrayLength - count
			int result[] = new int[remainder]

			for (int i = 0; i < remainder; i++)
			{
				result[i] = of[count+i]
			}

			return result
		}

		FunctionPrototype testFunction
		int testsFailed

		//NOTE: this function operates by "return" purely because adding to a global array within "ps" is super slow
		// (as it tends to expand an already-big array, rather than expanding incrementally smaller arrays as it goes)
		Node[] buildLines(PermutationSet ps, Node fastForward, bool globalFF, Node start, char returnType[], int lineCount, int globalLineCount, bool addReturn, FeatureBuilder featureBuilder)
		{
			Node programs[]
			//int linesRemaining = ps.totalLines - lineCount // NOT lines remaining - more like lines used?
			//out.println("totalLines: $(iu.intToString(ps.totalLines)), lineCount: $(iu.intToString(lineCount)), linesRemaining: $(iu.intToString(linesRemaining))")

			/* Node previousNode = clone start */

			int linesRemaining = globalLineCount - 1

			if (lineCount > 0)
			{
				Node options[] = buildNextLine(start, lineCount, addReturn, featureBuilder)
				//Node options[] = buildTree_summary(start, lineCount)
				int offset = 0

				if (fastForward != null)
				{
					//discount all of the options before the FF point
					options = removeFirstCells(options, fastForward.lines[ps.totalLines - lineCount])
					offset = fastForward.lines[ps.totalLines - lineCount]
				}

				/* PIFixed previousFeatures = clone start.features */
				for (int i = 0; i < options.arrayLength; i++)
				{
					int set = offset+i

					// NOTE: Compute similarity/distance to feature vector
					// Things we can pass to feature builder from here:
					// 	- Current line number
					// 	- The current Node
					//  - The next line
					//  - Input params?? from fp
					//  -
					//  -
					//  - Maybe should first check if declarations are finished, and if so, do a reachability test?
					// 	-
					/* Node currentNode = options[i] */
					Operation lineInfo = options[i].lineInfo

					/* PIFixed previousFeatures = options[i].features */
					/* options[i].features = featureBuilder.getNewFeatureVector() */

					/* PIFixed newFeatures = featureBuilder.updateFeatureVector(options[i].features, lineInfo.lineType, lineInfo.line, lineInfo.lineType, lineInfo.decType, lineInfo.asmtType) */
					/* options[i].features = featureBuilder.updateFeatureVector(previousFeatures, lineInfo.lineType, lineInfo.line, lineInfo.lineType, lineInfo.decType, lineInfo.asmtType) */

					/* bool programIsReachable = featureBuilder.areFeaturesReachable(options[i].features, options[i].declarationsComplete, linesRemaining)
					bool rejectEarly = featureBuilder.rejectEarly(options[i].features, linesRemaining) */

					PIFixed newFeatures = featureBuilder.updateFeatureVector(start.features, lineInfo.lineType, lineInfo.line, lineInfo.lineType, lineInfo.decType, lineInfo.asmtType)
					options[i].features = featureBuilder.copyFeatures(newFeatures)

					bool rejectBranch = featureBuilder.rejectBranch(options[i].features, options[i].declarationsComplete, linesRemaining)

					if (!rejectBranch)// (!rejectEarly && programIsReachable)
					{
						/* options[i].features = previousFeatures
						start.features = previousFeatures */

						testsFailed ++

						/* if (testsFailed % 100 == 0 && addReturn)
						{ */
							//out.println("ACL: $(iu.intToString(start.lines.arrayLength))")
							int currentLines[] = options[i].lines
							currentLines = new int[](start.lines, set)
							out.println("line count $(iu.intToString(options[i].arrayLength))/$(iu.intToString(lineCount)), globalLineCount $(iu.intToString(globalLineCount))")
							out.println("decType $(iu.intToString(options[i].lineInfo.decType))")
							out.println("asmtType $(iu.intToString(options[i].lineInfo.asmtType))")
							out.println("line $(options[i].lineInfo.line)")
							//(+2 to skip function header)
							//int postIndex = (options[i].arrayLength) + 2
							for (int j = 0; j < lineCount; j++) {
								currentLines = new int[](currentLines, 0)
							}
							String lines[] = decodeOption(testFunction, options[i])
							out.println("")
						  for (int j = 0; j < lines.arrayLength; j++) {
						  	out.print(lines[j].string)
								if (lines[j].string == options[i].lineInfo.line) out.println(" << --")
								else out.println("")
						  }
						/* } */
					}

					/* if (!rejectEarly && programIsReachable) { */
					if (!rejectBranch)//(!rejectEarly && programIsReachable)
					{
						/* options[i].features = newFeatures */
						// Decide if the current program is reachable - if not, don't continue.
						// return ???

						options[i].lines = new int[](start.lines, set)

						//ps.lineIndex ++
						/* int nextGLI = globalLineCount + 1 */
						int continueLineCount = lineCount - 1
						//int continueGlobalLineCount = linesRemaining

						//check for a sub-scope, and populate it if existing
						if (options[i].subLines.arrayLength != start.subLines.arrayLength)
						{
							SearchScope sc = options[i].subLines[start.subLines.arrayLength]
							sc.subLinesStart = options[i].lines.arrayLength

							PermutationSet subps = new PermutationSet(sc.subLinesCount, ps.globalLines, ps.totalLines - lineCount, 1)
							sc.root.features = options[i].features

							bool subGlobalFF = false

							// - apply global fast-forward, with prior lines removed
							if (fastForward != null)
							{
								subps.nextNode = clone fastForward
								subps.nextNode.lines = removeFirstIntCells(subps.nextNode.lines, sc.subLinesStart)
								subGlobalFF = true // don't allow any sub-scopes to advance if the parent scope is resuming
							}

							continueLineCount -= sc.subLinesCount
							//int subGLI = nextGLI + sc.subLinesCount
							int subGLCount = linesRemaining - sc.subLinesCount

							bool moreOptions = true
							while (moreOptions)
							{
								subps.found = 0
								Node subOption[] = buildLines(subps, subps.nextNode, subGlobalFF, sc.root, returnType, sc.subLinesCount, linesRemaining, false, featureBuilder)

								if (subOption != null)
								{
									//append the lines immediately from subps' only option
									Node optionN = clone options[i]

									// Do a feature update here too?

									optionN.lines = new int[](options[i].lines, subOption[0].lines)
									optionN.features = subOption[0].features

									//continue to populate the next line of code after the sub-scope
									// - the use of globalFF here is really strange to work out: what it's saying is, if I'm in a sub-scope already, an we're in a fast-forward, do NOT mess with the last line of this sub-scope, because the "resume" point of a fast-forward is ALWAYS from the last line of the function (i.e. the return); nothing else is allowed to move -- because last-line-returns completely ignore globalFF, this only gets noticed if we're on the last line of a sub-scope, where we *don't* want to skip the option
									Node childOptions[] = buildLines(ps, fastForward, globalFF, optionN, returnType, continueLineCount, subGLCount, addReturn, featureBuilder)

									if (childOptions != null) {
										programs = new Node[](programs, childOptions)

										if (ps.found == ps.limit)
										return programs
									}
								}
								else
								{
									moreOptions = false
								}


								fastForward = null
								subGlobalFF = false
							}
						}
						else
						{
							Node optionN = clone options[i]
							optionN.features = featureBuilder.copyFeatures(options[i].features)
							/* Node optionN = clone options[i] */
							//continue to populate the next line of code
							Node childOptions[] = buildLines(ps, fastForward, globalFF, optionN, returnType, continueLineCount, linesRemaining, addReturn, featureBuilder)

							if (childOptions != null) {
								programs = new Node[](programs, childOptions)

								if (ps.found == ps.limit)
								return programs
							}
						}

						fastForward = null
					}
					/* else { */
						/* options[i].features = previousFeatures */
						/* start.features = previousFeatures */
					/* } */
				}
				/* options[i].features = previousFeatures */
				/* start.features = previousFeatures */
			}
			else if (addReturn)
			{
				//out.println("End of program")
				//add return statements, for every possible variable that matches our return type...
				Node options[] = buildReturns(start, returnType)
				int offset = 0
				Node selection[]

				if (fastForward != null)
				{
					//discount all of the options before the FF point, plus one
					options = removeFirstCells(options, fastForward.lines[ps.totalLines - lineCount] + 1)
					offset = fastForward.lines[ps.totalLines - lineCount] + 1
				}

				for (int i = 0; i < options.arrayLength; i++)
				{
					int set = offset+i

					// NOTE: Measure final distance of feature vector here.
					Node currentNode = options[i]
					Operation lineInfo = currentNode.lineInfo
					// Shouldn't need to update again here, just using existing features, return doens't add anything
					/* options[i].features = featureBuilder.updateFeatureVector(start.features, lineInfo.lineType, lineInfo.line, lineInfo.lineType, lineInfo.decType, lineInfo.asmtType) */
					bool programClosenessCheck = true//featureBuilder.programHasMinimumFeatures(options[i].features, linesRemaining)//true//featureBuilder.isProgramSimilar(options[i].features)

					// Replace this with a check to find if all features are included.
					if (programClosenessCheck) {
						options[i].lines = new int[](start.lines, set)
						selection = new Node[](selection, options[i])

						ps.found ++


						if (ps.found == ps.limit)
						{
							ps.nextNode = options[i]
							break
						}
					}
				}

				//ps.nodes = new Node[](ps.nodes, options[i])

				//ps.nodes = new Node[](ps.nodes, selection)

				return selection
			}
			else
			{
				//ignore this option if we're in a local FF
				if (fastForward == null || globalFF)
				{
					//ps.nodes = new Node[](ps.nodes, start)

					ps.found = 1

					ps.nextNode = start

					return start
				}
			}

			return programs
		}

		Node buildRandomLine(Node start, char returnType[], int lineCount, bool addReturn, RandomInt rgen, FeatureBuilder featureBuilder)
		{
			if (lineCount > 0)
			{
				Node options[] = buildNextLine(start, lineCount, addReturn, featureBuilder)

				if (options == null)
				return null

				int ndx = rgen.get(options.arrayLength)

				Node nxt = options[ndx]

				nxt.lines = new int[](start.lines, ndx)

				int continueLineCount = lineCount - 1

				if (nxt.subLines.arrayLength != start.subLines.arrayLength)
				{
					SearchScope sc = nxt.subLines[start.subLines.arrayLength]
					sc.subLinesStart = nxt.lines.arrayLength

					continueLineCount -= sc.subLinesCount

					Node subOption = buildRandomLine(sc.root, returnType, sc.subLinesCount, false, rgen, featureBuilder)

					nxt.lines = new int[](nxt.lines, subOption.lines)

					return buildRandomLine(nxt, returnType, continueLineCount, addReturn, rgen, featureBuilder)
				}
				else
				{
					return buildRandomLine(nxt, returnType, continueLineCount, addReturn, rgen, featureBuilder)
				}
			}
			else if (addReturn)
			{
				//add return statements, for every possible variable that matches our return type...
				Node options[] = buildReturns(start, returnType)

				int ndx = rgen.get(options.arrayLength)

				Node nxt = options[ndx]

				nxt.lines = new int[](start.lines, ndx)

				return nxt
			}
			else
			{
				return start
			}

			return null
		}

		// -- public API --

		void Generator:addResource(char package[])
		{
			//find the interface, parse it into a type (use part of DocGen for this???), add to APIs list
			// - also note if it has a constructor, so we know whether we can have a single global instance, or need to instantiate locals
			char filepath[] = findPackage(searchDirectories, package)

			if (filepath != null)
			{
				// - parse the interface
				DocBuilder db = new DocBuilder()
				db.parseFile(filepath)

				ParsedFiles pf = db.getParsedFiles()

				// - add all types by name (if not existing), then add type structures

				for (int i = 0; i < pf.primaryFiles.arrayLength; i++)
				{
					TypeDef xtypes[] = pf.primaryFiles[i].types

					for (int j = 0; j < xtypes.arrayLength; j ++)
					{
						if (getType(xtypes[j].name) == null)
						{
							out.println(" -- adding type $(xtypes[j].name)")
							types = new DataType[](types, new DataType(xtypes[j].name, package, new Type()))
							addArrayType(types[types.arrayLength-1])
						}
					}
				}

				for (int i = 0; i < pf.supportFiles.arrayLength; i++)
				{
					TypeDef xtypes[] = pf.supportFiles[i].types

					for (int j = 0; j < xtypes.arrayLength; j ++)
					{
						if (getType(xtypes[j].name) == null)
						{
							out.println(" -- adding type $(xtypes[j].name)")
							types = new DataType[](types, new DataType(xtypes[j].name, package, new Type()))
							addArrayType(types[types.arrayLength-1])
						}
					}
				}

				// - now populate type structures

				for (int i = 0; i < pf.primaryFiles.arrayLength; i++)
				{
					TypeDef xtypes[] = pf.primaryFiles[i].types

					for (int j = 0; j < xtypes.arrayLength; j ++)
					{
						populateTypeStructure(getType(xtypes[j].name), xtypes[j])
					}
				}

				for (int i = 0; i < pf.supportFiles.arrayLength; i++)
				{
					TypeDef xtypes[] = pf.supportFiles[i].types

					for (int j = 0; j < xtypes.arrayLength; j ++)
					{
						populateTypeStructure(getType(xtypes[j].name), xtypes[j])
					}
				}
			}
		}

		void Generator:addGlobalAPI(char package[])
		{
			//for every object type that doesn't have a constructor, add to our global APIs
			String parts[] = stringUtil.explode(package, ".")
			char typeName[] = parts[parts.arrayLength-1].string

			DataType dt = getType(typeName)

			//check for a constructor
			if (search.search(dt.type.fields, Field.[name], new Field(null, dt.name)) == null)
			{
				addGlobalObject(dt)
				out.println(" -- global API $(dt.name)")
			}
			else
			{
				addInstantiableObject(dt)
			}
		}

		//NOTE pass feature vector here!
		OptionSet Generator:getOptions(FunctionPrototype fp, int lineCount, int maxOptions, Option resumeFrom, FeatureBuilder featureBuilder)
		{
			if (featureBuilder == null) out.println("FeatureBuilder is null in getOptions")
			PermutationSet ps = new PermutationSet(lineCount, lineCount, maxOptions)

			testFunction = fp

			int ins[] = null

			for (int i = 0; i < fp.parameterTypes.arrayLength; i++)
			{
				ins = new int[](ins, getTypeIndex(getType(fp.parameterTypes[i].string).type))
			}

			Node root = new Node(null, ins)

			// NOTE: pass feature vector here:
			Node options[] = buildLines(ps, resumeFrom, false, root, fp.returnType, lineCount, lineCount, true, featureBuilder)

			OptionSet result = new OptionSet(options, ps.nextNode)

			return result
		}

		Option Generator:getRandomOption(FunctionPrototype fp, int lineCount, RandomInt randomSource, FeatureBuilder featureBuilder)
		{
			int ins[] = null

			for (int i = 0; i < fp.parameterTypes.arrayLength; i++)
			{
				ins = new int[](ins, getTypeIndex(getType(fp.parameterTypes[i].string).type))
			}

			Node root = new Node(null, ins)

			Node choice = null

			while (choice == null)
			{
				choice = buildRandomLine(clone root, fp.returnType, lineCount, true, randomSource, featureBuilder)
			}

			return choice
		}

		String[] Generator:decodeOption(FunctionPrototype fp, Option leaf)
		{
			String lines[]

			bool declarationsComplete
			bool blankLines

			//this is a decoder over the "lines" of leaf, building our variable list as we go
			// - we'll account for scopes using a stack, and clone our variable list for each nesting depth, then drop the stack frame
			// - note that the last line is a return, so sourced from possible returns only

			//init variables in "ins" with the param count of fp
			int ins[] = null

			for (int i = 0; i < fp.parameterTypes.arrayLength; i++)
			{
				ins = new int[](ins, getTypeIndex(getType(fp.parameterTypes[i].string).type))
			}

			ScopeStackItem top = new ScopeStackItem(ins, leaf.lines.arrayLength - 1)

			for (int i = 0; i < leaf.lines.arrayLength; i++)
			{
				//get all options, use the i'th one
				// - if it's a variable declare, add to "ins"

				Operation options[]

				//check if it's time to generate a return value
				if (top.remainingLines == 0 && top.next == null)
				options = generateReturns(top.ins, fp.returnType)
				else
				options = generateOperations(top.ins, top.remainingLines, declarationsComplete, blankLines, top.next == null)

				Operation choice = options[leaf.lines[i]]

				if (choice.newVar == null) declarationsComplete = true
				if (choice.line == null) blankLines = true

				// - if it's a sub-scope, clone ins and stack it up
				//  - then just continue as normal until the end of the sub-scope, and wrap the sub-scope in {}
				lines = new String[](lines, new String(choice.line))

				if (choice.newVar != null)
				{
					top.ins = new int[](top.ins, choice.newVar.typeIndex)
				}

				top.remainingLines --

				if (choice.subLinesCount != 0)
				{
					//stack things up
					lines = new String[](lines, new String("{"))

					ScopeStackItem newTop = new ScopeStackItem(top.ins, choice.subLinesCount, choice.subLinesCount)
					newTop.next = top

					top = newTop
				}
				else
				{
					//check for the end of a scope (or multiple scopes)
					while (top.next != null && top.remainingLines == 0)
					//if (top.remainingLines == 0)
					{
						if (top.next != null)
						{
							top.next.remainingLines -= top.totalLines
							lines = new String[](lines, new String("}"))
						}

						top = top.next
					}
				}
			}

			// -- now build the function header and braces around the implementation
			char fhdr[]

			if (fp.interfaceMember != null)
			fhdr = "$(fp.returnType) $(fp.interfaceMember):$(fp.name)"
			else
			fhdr = "$(fp.returnType) $(fp.name)"

			fhdr = new char[](fhdr, "(")

			//params
			for (int i = 0; i < fp.parameterTypes.arrayLength; i++)
			{
				if (i > 0) fhdr = new char[](fhdr, ",")

				bool arrayType = false
				char vtype[] = fp.parameterTypes[i].string

				/* NOTE: could be useful for feature building */
				if (stringUtil.find(vtype, "[]") != StringUtil.NOT_FOUND)
				{
					vtype = stringUtil.subString(vtype, 0, stringUtil.find(vtype, "[]"))
					arrayType = true
				}

				if (!arrayType)
				fhdr = new char[](fhdr, vtype, " ", "locv_$(iu.intToString(i))")
				else
				fhdr = new char[](fhdr, vtype, " ", "locv_$(iu.intToString(i))", "[]")
			}

			fhdr = new char[](fhdr, ")")

			lines = new String[](new String(fhdr),
			new String("{"),
			lines,
			new String("}")
			)

			return lines
		}

		String[] Generator:getRequiresList()
		{
			String result[]

			for (int i = 0; i < globalObjects.arrayLength; i++)
			{
				result = new String[](result, new String("$(globalObjects[i].t.package) $(globalObjects[i].name)"))
			}

			return result
		}

	}
